<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>环形进度系统</title>
    <style>
        /* 深色模式基础样式 */
        body {
            margin: 0;
            padding: 0;
            background: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
            overflow: hidden; /* 防止滚动条出现 */
            display: flex; /* 使用 flexbox 将内容居中 */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* 确保body至少占满视口高度 */
        }
        /* 圆环容器，固定大小并居中 */
        .ring-container {
            position: relative; /* 允许子元素绝对定位 */
            width: 600px; /* 固定宽度 */
            height: 600px; /* 固定高度 */
            /* flexbox 已处理居中 */
        }
        /* 主圆环样式 - 根据视频，外圈圆环不是很明显，可以稍微调整样式或透明度 */
        .main-ring {
            position: absolute;
            width: 100%; /* 占满父容器 (ring-container) */
            height: 100%; /* 占满父容器 */
            /* 视频中外圈不突出，可以降低透明度或颜色 */
            border: 2px solid rgba(204, 0, 0, 0.3); /* 细边框，深红色，半透明 */
            border-radius: 50%;
            top: 0;
            left: 0;
        }
        /* 进度环 SVG 容器 */
        .progress-svg {
            position: absolute;
            width: 100%; /* 占满父容器 */
            height: 100%; /* 占满父容器 */
            top: 0;
            left: 0;
            /* viewBox="0 0 600 600" 在 SVG 标签上 */
            overflow: visible; /* 防止路径的stroke-linecap在边界被裁切 */
        }
        /* SVG 段路径样式 */
        .segment-path {
            fill: none; /* 不填充区域 */
            stroke: #66ccff; /* 浅蓝色描边 */
            stroke-width: 4px; /* 描边宽度 */
            stroke-linecap: round; /* 使描边端点圆润 */
            /* 初始隐藏，动画会改变 stroke-dashoffset */
            opacity: 0; /* 初始不可见 */
            transition: none; /* 移除 stroke-dashoffset 的 CSS transition */
        }

        /* 移动的点样式 */
        .traveling-dot {
            fill: #ffffff; /* 点的颜色 */
            r: 4px; /* 点的半径 */
            display: none; /* 初始隐藏 */
        }


        /* 节点基础样式 */
        .node {
            position: absolute;
            /* top/left 将由JavaScript精确计算设置 */
            cursor: pointer; /* 鼠标悬停显示手型 */
            z-index: 2; /* 放在圆环上方 */
            text-align: center; /* 文本居中 */
            box-sizing: border-box; /* 边框和内边距包含在元素的 width/height 内 */
            border: 2px solid #ffffff; /* 白色边框 */
             transition: background 0.3s ease, border-color 0.3s ease; /* 添加背景和边框颜色动画 */
        }
        /* 节点尺寸 */
        .node.diamond, .node.square, .center-node {
             width: 40px;
             height: 40px;
        }
        /* 菱形节点样式（索引0） */
        .node.diamond {
            background: #ffffff; /* 默认白色背景 */
            /* transform 会在 JS 设置 top/left 后应用 */
        }
        /* 正方形节点样式 */
        .node.square {
            background: #333; /* 未解锁时为深色背景 */
             /* transform 会在 JS 设置 top/left 后应用 */
        }

        /* 中间节点样式（索引6） */
        .center-node {
            width: 60px;
            height: 60px;
            background: #333; /* 未启用时为深色背景 */
            opacity: 0.5; /* 半透明 */
            pointer-events: none; /* 默认不可点击 */
            display: flex; /* 使文字居中 */
            justify-content: center; /* 文字水平居中 */
            align-items: center; /* 文字垂直居中 */
            font-size: 14px; /* 文字大小 */
            color: #ffffff; /* 文字颜色 */
            /* transform 会在 JS 设置 top/left 后应用 */
             transition: opacity 0.3s ease, background 0.3s ease, color 0.3s ease, pointer-events 0.3s ease; /* 添加状态变化动画 */
        }

        /* 解锁节点样式 */
        .node.unlocked.diamond,
        .node.unlocked.square {
             background: #66ccff; /* 解锁后变为浅蓝色 */
             border-color: #66ccff; /* 边框颜色也变 */
        }
        .center-node.enabled {
             opacity: 1; /* 完全不透明 */
             pointer-events: auto; /* 启用后可点击 */
             background: #ffffff; /* 启用后背景变白色 */
             color: #121212; /* 启用后文字变深色 */
        }

        /* 提示框样式 */
        .tooltip {
            position: fixed; /* 固定在视口中 */
            right: 20px; /* 距离右侧 20px */
            top: 20px; /* 距离顶部 20px */
            width: 300px; /* 固定宽度 */
            height: 80vh; /* 高度为视口高度的 80% */
            background: #1e1e1e; /* 深色背景 */
            border: 2px solid #ffffff; /* 白色边框 */
            overflow-y: auto; /* 垂直方向允许滚动 */
            padding: 10px; /* 内边距 */
            box-sizing: border-box; /* 边框和内边距包含在 width/height 内 */
            display: none; /* 默认隐藏 */
            z-index: 3; /* 放在最顶层 */
            color: #cccccc; /* 文字颜色 */
        }

        /* 密码输入区域 */
        .password-form {
            position: sticky; /* 尝试固定在滚动区域底部，兼容性需注意 */
            bottom: 0; /* 固定在底部 */
            background: #1e1e1e; /* 与提示框背景一致 */
            padding: 10px 0 0 0; /* 上边距，左右下无内边距 */
            margin: 0; /* 无外边距 */
            width: 100%; /* 占满父容器宽度 */
            box-sizing: border-box;
        }
        .password-form input[type="password"] {
            width: calc(100% - 18px); /* 调整宽度以适应内边距和边框 */
            padding: 8px; /* 内边距 */
            margin-bottom: 5px; /* 下边距 */
            box-sizing: border-box;
            background: #333; /* 输入框背景色 */
            color: white; /* 文字颜色 */
            border: 1px solid #666; /* 边框颜色 */
            display: block; /* 使元素独占一行 */
        }
        .password-form button {
            width: 100%; /* 占满父容器宽度 */
            padding: 8px; /* 内边距 */
            background: #4CAF50; /* 背景绿色 */
            color: white; /* 文字白色 */
            border: none; /* 无边框 */
            cursor: pointer; /* 鼠标悬停显示手型 */
            display: block; /* 使元素独占一行 */
             transition: background 0.3s ease; /* 背景颜色变化动画 */
        }
        .password-form button:hover {
            background: #45a049; /* 鼠标悬停背景变深 */
        }
        .error {
            color: red; /* 文字红色 */
            text-align: center; /* 文字居中 */
            margin-top: 5px; /* 上边距 */
            font-size: 0.9em; /* 文字大小 */
        }
        #tooltipContent {
            margin-bottom: 20px; /* 在内容和密码表单之间留白 */
             word-wrap: break-word; /* 防止长文本溢出 */
             white-space: pre-wrap; /* 保留换行符，使说明文字格式更灵活 */
        }
         .tooltip p {
             margin: 0 0 10px 0; /* 段落下边距 */
             line-height: 1.5; /* 行高 */
         }
    </style>
</head>
<body>
    <div class="ring-container">
        <!-- 主圆环 -->
        <div class="main-ring"></div>
        <!-- 进度环 SVG -->
        <svg class="progress-svg" viewBox="0 0 600 600">
            <!-- SVG 内部坐标系范围，圆心在 300, 300 -->
            <!-- 段路径，由JavaScript动态生成并控制显隐和动画 -->
            <!-- 将段路径放在点的前面，确保点绘制在路径上方 -->
            <path id="segmentPath-0-1" class="segment-path"/>
            <path id="segmentPath-1-2" class="segment-path"/>
            <path id="segmentPath-2-3" class="segment-path"/>
            <path id="segmentPath-3-4" class="segment-path"/>
            <path id="segmentPath-4-5" class="segment-path"/>
            <!-- 新增从节点5到节点0的路径 -->
            <path id="segmentPath-5-0" class="segment-path"/>

            <!-- 移动的点 -->
            <circle id="travelingDot" class="traveling-dot"/>
        </svg>
        <!-- 节点组 -->
        <div class="nodes">
            <!-- 节点的位置和 transform 将通过 JavaScript 精确计算并设置 style -->
            <!-- data-index 对应解锁顺序： 0(菱形) -> 1 -> 2 -> 3 -> 4 -> 5 (正方形) -->
            <!-- HTML 元素的顺序应该与 data-index 一致，方便 JS 获取 -->

            <!-- data-index 0: 菱形, 底部 (解锁顺序起点) -->
            <div class="node diamond" data-index="0"></div>

             <!-- data-index 1: 正方形, 左下 (解锁顺序 1) -->
            <div class="node square" data-index="1"></div>

             <!-- data-index 2: 正方形, 左上 (解锁顺序 2) -->
            <div class="node square" data-index="2"></div>

             <!-- data-index 3: 正方形, 顶部 (解锁顺序 3) -->
            <div class="node square" data-index="3"></div>

             <!-- data-index 4: 正方形, 右上 (解锁顺序 4) -->
            <div class="node square" data-index="4"></div>

             <!-- data-index 5: 正方形, 右下 (解锁顺序 5) -->
            <div class="node square" data-index="5"></div>

            <!-- 中间节点 (索引6) -->
            <div class="node center-node" id="centerNode" data-index="6">
                中心
            </div>
        </div>
    </div>
    <!-- 提示框 -->
    <div class="tooltip" id="tooltip">
        <div id="tooltipContent">这里是节点说明文字...</div>
        <div class="password-form" id="passwordForm">
            <input type="password" id="passwordInput" placeholder="请输入密码">
            <button id="unlockButton">解锁</button>
            <div class="error" id="errorMsg"></div>
        </div>
    </div>
    <script>
        // ========== 可配置参数 ==========

        // 节点角度定义 (Math/JS 角度: 0=右, 90=下, 180=左, 270=上)
        // 顺序与解锁顺序一致： 0(底部菱形) -> 1(左下) -> 2(左上) -> 3(顶部) -> 4(右上) -> 5(右下)
        const nodeAngles = [90, 150, 210, 270, 330, 30]; // 6个环形节点角度

        const nodeDescriptions = [
            "这是位于最下方的菱形节点，它是整个系统的起点。\n它无需密码即可查看说明。",   // 节点0 (菱形, 底部)
            "这是解锁序列的第一个正方形节点 (左下)。\n解锁它将开启系统。\n提示：密码是 node1pass", // 节点1 (左下)
            "这是解锁序列的第二个正方形节点 (左上)。\n提示：密码是 node2pass",       // 节点2 (左上)
            "这是解锁序列的第三个正方形节点 (顶部)。\n提示：密码是 node3pass",       // 节点3 (顶部)
            "这是解锁序列的第四个正方形节点 (右上)。\n提示：密码是 node4pass",       // 节点4 (右上)
            "这是解锁序列的第五个正方形节点 (右下)。\n解锁它将开启中心节点。\n提示：密码是 node5pass", // 节点5 (右下)
            "恭喜！你已解锁所有环形节点。这是中心节点。\n在所有环形节点解锁后，输入密码即可访问下一阶段。\n提示：密码是 centerpass"  // 节点6 (中心)
        ];
        const nodePasswords = [
            "",                     // 节点0 (菱形) 无需密码解锁
            "node1pass",            // 节点1 (左下) 密码
            "node2pass",            // 节点2 (左上) 密码
            "node3pass",            // 节点3 (顶部) 密码
            "node4pass",            // 节点4 (右上) 密码
            "node5pass",            // 5 (右下) 密码
            "centerpass"            // 节点6 (中心) 密码
        ];

        const animationDuration = 2000; // 单段动画时长 (毫秒)
        const fullCircleAnimationDuration = 3000; // 解锁节点5时的整个圆环动画时长

        // ========== 配置结束 ==========

        // 获取DOM元素
        const nodes = document.querySelectorAll('.node'); // 获取所有节点元素 (顺序应与HTML中的data-index一致)
        const tooltip = document.getElementById('tooltip');
        const tooltipContent = document.getElementById('tooltipContent');
        const passwordForm = document.getElementById('passwordForm');
        const passwordInput = document.getElementById('passwordInput');
        const unlockButton = document.getElementById('unlockButton');
        const errorMsg = document.getElementById('errorMsg');
        const centerNode = document.getElementById('centerNode');
        const travelingDot = document.getElementById('travelingDot'); // 获取移动点元素

        // 获取段路径元素。现在有 6 段路径：0-1, 1-2, ..., 4-5, 5-0
        const segmentPaths = [];
        for(let i = 0; i < 5; i++) { // 5段路径：0-1, 1-2, ..., 4-5
            segmentPaths.push(document.getElementById(`segmentPath-${i}-${i+1}`));
        }
        segmentPaths.push(document.getElementById(`segmentPath-5-0`)); // 添加最后一段路径 5-0


        // unlockedNodes[i] 为 true 表示索引 i 的节点 (0-5) 已解锁
        // 节点0 (菱形) 默认解锁，作为起点
        let unlockedNodes = [true, false, false, false, false, false]; // 节点0-5 的解锁状态
        let isCenterEnabled = false; // 中心节点默认锁定
        let currentNodeIndex = null; // 当前选中的节点索引 (0-6)

        // 圆的参数 (基于 600x600 的 SVG viewBox)
        const radius = 300;
        const circleCenterX = 300; // SVG 内部坐标系中的圆心 X 坐标 (也是ring-container的中心)
        const circleCenterY = 300; // SVG 内部坐标系中的圆心 Y 坐标 (也是ring-container的中心)


        // --- 初始化设置 ---

        // 1. 精确定位节点
        positionNodes();

        // 2. 创建段路径几何信息 (d属性)
        createSegmentPaths();

        // 3. 标记菱形节点 (node 0) 为视觉上的解锁/起点状态
        // 因为我们在 HTML 中调整了顺序，nodes[0] 应该就是菱形节点
        if (nodes[0].classList.contains('diamond')) {
             nodes[0].classList.add('unlocked');
        }


        function calculateNodeSvgPosition(angleDeg) {
             // 将角度转换为弧度
             // 记住 Math.cos/sin 使用弧度，且 0度在正右方，角度逆时针增加
             // 我们的 nodeAngles 遵循 Math/JS 标准 (0=右, 90=下, 180=左, 270=上)
             const angleRad = angleDeg * Math.PI / 180;

             // 计算相对于圆心的坐标，然后加上圆心坐标 (圆心在 SVG 的 300, 300)
             // 注意：在 SVG 坐标系中，Y轴向下为正
             const nodeX = circleCenterX + radius * Math.cos(angleRad);
             const nodeY = circleCenterY + radius * Math.sin(angleRad);

             return { x: nodeX, y: nodeY };
        }


        // 根据计算出的 SVG 坐标定位 HTML 节点元素
        function positionNodes() {
            // 节点的 top/left 设置为 SVG 坐标，然后通过 translate(-50%, -50%) 将节点自身中心对齐到该点
            // ring-container 就是 SVG 的绘制区域，其左上角 (0,0) 对应 SVG 的 (0,0)
            // 遍历获取到的 nodes NodeList
            nodes.forEach((node) => {
                const index = parseInt(node.dataset.index); // 使用 data-index 获取节点的逻辑索引 (0-6)

                if (index === 6) { // 中心节点
                    // 中心节点通过 CSS position: 50% 50% 和 transform: translate(-50%, -50%) 居中
                    node.style.left = '50%';
                    node.style.top = '50%';
                    node.style.transform = 'translate(-50%, -50%)';
                    return;
                }

                // 对于环形节点 (索引 0-5)，使用 nodeAngles数组中对应索引的角度
                const angleDeg = nodeAngles[index]; // 使用 data-index 作为 nodeAngles 的索引
                // 计算节点在 SVG坐标系中的位置 (相对于 SVG 左上角)，也就是相对于 ring-container 左上角的位置
                const svgPos = calculateNodeSvgPosition(angleDeg);

                // 设置节点的 top/left 属性
                node.style.top = `${svgPos.y}px`;
                node.style.left = `${svgPos.x}px`;

                // 添加 transform 用于元素自身居中 和 形状旋转 (对于菱形)
                if (node.classList.contains('diamond')) {
                     // 菱形需要额外的 45度旋转才能在定位后看起来是菱形
                     node.style.transform = `translate(-50%, -50%) rotate(45deg)`;
                } else {
                     // 正方形只需自身居中
                     node.style.transform = `translate(-50%, -50%)`;
                }
            });
        }

        // 创建并设置段路径的几何信息 (d属性)
        function createSegmentPaths() {
             // 6 段路径: 0-1, 1-2, 2-3, 3-4, 4-5, 5-0
             // 数组 segmentPaths 的索引 0-4 对应 0-1 到 4-5
             // 数组 segmentPaths 的索引 5 对应 5-0

             for (let i = 0; i < 6; i++) {
                 let startNodeIndex, endNodeIndex;
                 if (i < 5) {
                     startNodeIndex = i;
                     endNodeIndex = i + 1;
                 } else { // 这是最后一段，从节点 5 到节点 0
                     startNodeIndex = 5;
                     endNodeIndex = 0;
                 }

                 const startPos = calculateNodeSvgPosition(nodeAngles[startNodeIndex]);
                 const endPos = calculateNodeSvgPosition(nodeAngles[endNodeIndex]);

                 // SVG Arc command: A rx ry x-axis-rotation large-arc-flag sweep-flag x y
                 // rx, ry = radius (我们是圆，所以rx=ry=radius)
                 // x-axis-rotation = 0 (圆没有轴旋转)
                 // large-arc-flag = 0 (每段都是 60度，小于 180度)
                 // sweep-flag = 1 (逆时针绘制，与视频一致)

                 const pathData = `M ${startPos.x} ${startPos.y} A ${radius} ${radius} 0 0 1 ${endPos.x} ${endPos.y}`;

                 const pathElement = segmentPaths[i]; // 获取对应的 path 元素
                 pathElement.setAttribute('d', pathData);

                 // 初始隐藏段路径，通过 opacity 和 stroke-dashoffset
                 pathElement.style.opacity = 0; // 初始不可见
                 const pathLength = pathElement.getTotalLength();
                 pathElement.style.strokeDasharray = pathLength;
                 pathElement.style.strokeDashoffset = pathLength; // 完全偏移隐藏
                 // pathElement.style.stroke = '#66ccff'; // 初始不设置颜色，由JS控制
             }
        }


        // 显示提示框
        function showTooltip(needsPassword) {
            if (currentNodeIndex === null) return;

            tooltip.style.display = 'block'; // 显示提示框
            tooltipContent.textContent = nodeDescriptions[currentNodeIndex]; // 设置提示内容
            errorMsg.textContent = ''; // 清空之前的错误信息

            if (needsPassword) {
                passwordForm.style.display = 'block'; // 显示密码输入区域
                passwordInput.value = ''; // 清空密码输入框
                 // 根据节点类型设置解锁按钮文本
                 unlockButton.textContent = currentNodeIndex === 6 ? '进入' : '解锁';
            } else {
                passwordForm.style.display = 'none'; // 隐藏密码输入区域
            }

            tooltip.scrollTop = 0; // 显示提示框时滚动到顶部
        }

        // 检查密码并处理解锁
        function checkPassword() {
            if (currentNodeIndex === null) return;

            const input = passwordInput.value;
            // 检查输入的密码是否与当前节点的密码匹配
            if (input === nodePasswords[currentNodeIndex]) {
                errorMsg.textContent = ''; // 清空错误信息
                tooltip.style.display = 'none'; // 隐藏提示框

                if (currentNodeIndex >= 1 && currentNodeIndex <= 5) {
                    // 解锁环形节点 (1-5)
                    // 仅在节点未解锁时执行动画和解锁逻辑
                    if (!unlockedNodes[currentNodeIndex]) {
                         unlockedNodes[currentNodeIndex] = true; // 更新解锁状态数组

                         // 找到对应的 DOM 节点 (通过 data-index) 并添加 unlocked 类
                         const targetNode = document.querySelector(`.node[data-index="${currentNodeIndex}"]`);
                         if (targetNode) {
                              targetNode.classList.add('unlocked'); // 给节点添加视觉反馈类 (变色)
                         }

                         // --- 特殊逻辑：解锁节点 5 时，连续动画两个段，并使整个圆环激活 ---
                         if (currentNodeIndex === 5) {
                             // 动画绘制 4->5 段
                             animatePathSegment(4, () => {
                                 // 4->5 动画完成后，立即开始绘制 5->0 段
                                 animatePathSegment(5, () => { // segment index 5 is for path 5-0
                                     // 5->0 动画完成后，整个环形路径绘制完毕
                                     console.log("环形路径解锁完成！");
                                     // 确保所有段路径都完全绘制并显示激活颜色
                                     segmentPaths.forEach(pathElement => {
                                         pathElement.style.opacity = 1;
                                         pathElement.style.stroke = '#66ccff'; // 确保颜色正确
                                         pathElement.style.strokeDashoffset = 0; // 确保完全绘制
                                     });

                                     // 检查是否所有环形节点 (1-5) 都已解锁，然后启用中心节点
                                     let allRingNodesUnlocked = true; // 理论上到这里节点1-5都已解锁
                                     for(let i = 1; i <= 5; i++) {
                                         if (!unlockedNodes[i]) {
                                             allRingNodesUnlocked = false;
                                             break;
                                         }
                                     }
                                     if (allRingNodesUnlocked) {
                                         enableCenterNode();
                                     }
                                 }); // End of inner animatePathSegment callback
                             }); // End of outer animatePathSegment callback

                         } else {
                             // 对于节点 1-4 的解锁，只动画当前段路径 (currentNodeIndex - 1)
                             animatePathSegment(currentNodeIndex - 1);
                             // 节点 1-4 解锁时不需要检查全环解锁，只在节点 5 解锁时检查
                         }
                         // --- 特殊逻辑结束 ---

                    } // End of if (!unlockedNodes[currentNodeIndex])

                } else if (currentNodeIndex === 6 && isCenterEnabled) {
                    // 已启用中心节点且密码正确 - 执行下一步操作 (例如页面跳转)
                    alert("中心节点解锁成功！即将进入下一阶段..."); // 示例弹窗
                    // window.location.href = 'next.html'; // 示例页面跳转
                }

                 currentNodeIndex = null; // 操作成功后重置当前节点索引
            } else {
                errorMsg.textContent = '密钥错误！'; // 显示错误信息
                passwordInput.value = ''; // 清空输入框，方便重新输入
            }
        }

        // 动画函数：移动点沿着路径移动并显示路径
        // segmentIndex: 要动画的段路径的索引 (0-5)
        // onComplete: 动画完成时执行的回调函数
        function animatePathSegment(segmentIndex, onComplete = null) {
            const pathElement = segmentPaths[segmentIndex];

            if (!pathElement) return; // 确保段路径存在

            const pathLength = pathElement.getTotalLength();

            // 设置段路径初始状态：可见但未绘制
            pathElement.style.opacity = 1; // 使路径可见
            pathElement.style.strokeDasharray = pathLength;
            pathElement.style.strokeDashoffset = pathLength; // 完全偏移隐藏

            // 设置移动点初始位置并显示
            const startPoint = pathElement.getPointAtLength(0);
            travelingDot.setAttribute('cx', startPoint.x);
            travelingDot.setAttribute('cy', startPoint.y);
            travelingDot.style.display = 'block'; // 显示点

            let startTime = null;
            const duration = (segmentIndex === 4 || segmentIndex === 5) ? fullCircleAnimationDuration / 2 : animationDuration; // 节点5解锁时的两段动画总时长，每段一半

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime; // 已经过去的时间
                const progress = Math.min(elapsed / duration, 1); // 动画进度 (0 到 1)

                const currentLength = pathLength * progress; // 点在路径上的当前长度
                const currentPoint = pathElement.getPointAtLength(currentLength); // 点的当前坐标

                // 更新点的位置
                travelingDot.setAttribute('cx', currentPoint.x);
                travelingDot.setAttribute('cy', currentPoint.y);

                // 更新路径的 stroke-dashoffset，使其逐渐显示
                pathElement.style.strokeDashoffset = pathLength - currentLength;

                // 如果动画未结束，继续下一帧
                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    // 动画结束
                    pathElement.style.strokeDashoffset = 0; // 确保路径完全显示
                    // 点在这里不立即隐藏，如果onComplete存在，点会留在终点直到下一段动画开始
                    // 如果没有onComplete，则隐藏点
                    if (!onComplete) {
                       travelingDot.style.display = 'none';
                    }

                    // 执行完成回调
                    if (onComplete) {
                        onComplete();
                    }
                }
            }

            // 启动动画
            requestAnimationFrame(step);
        }


        // 启用中心节点 (解锁后状态)
        function enableCenterNode() {
            isCenterEnabled = true; // 标记中心节点为已启用
            centerNode.classList.add('enabled'); // 给中心节点添加视觉反馈类 (变色，可点击)
            console.log("中心节点已解锁！"); // 控制台输出提示
        }

        // --- 事件监听 ---

        // 给所有节点 (0-6) 添加点击监听
        // 使用事件委托可能会更有效率，但对于少量节点，直接监听也可
        nodes.forEach(node => {
            // 使用 data-index 属性获取节点的逻辑索引
            const index = parseInt(node.dataset.index);

            node.addEventListener('click', (e) => {
                 e.stopPropagation(); // 阻止点击事件冒泡，防止点击节点时同时触发 document 的点击事件关闭提示框

                 if (index === 6) { // 中心节点 (索引6) 的特殊处理
                     // 中心节点即使未启用也可以点击查看描述
                     currentNodeIndex = index;
                     showTooltip(isCenterEnabled); // 中心节点是否需要密码取决于是否启用
                     return; // 中心节点处理完毕，退出循环
                 }

                 // 对于环形节点 (0-5) 的处理
                 // 检查前一个节点是否已解锁 (除了节点0自身)
                 if (index > 0 && !unlockedNodes[index - 1]) {
                     alert("请按顺序解锁前一个节点！"); // 弹出提示
                     return; // 如果前一个未解锁，阻止进一步操作
                 }

                 // 如果当前节点 (索引 index) 已解锁 (或者它是节点0)，只显示信息，无需密码输入框
                 if (unlockedNodes[index]) {
                     currentNodeIndex = index;
                     showTooltip(false); // 显示当前节点的描述，不显示密码输入区域
                 } else {
                      // 当前节点未解锁，且前一个已解锁 (或当前是节点0)，显示提示框并要求输入密码 (节点0不需要密码)
                      currentNodeIndex = index;
                      showTooltip(index !== 0); // 节点0不需要密码，其他节点需要
                 }
            });
        });

        // 解锁按钮点击事件处理函数
        unlockButton.addEventListener('click', checkPassword);

        // 监听密码输入框回车事件
        passwordInput.addEventListener('keypress', function(event) {
            // 检查是否按下回车键 (event.key === 'Enter' 是现代方法)
            if (event.key === 'Enter') {
                event.preventDefault(); // 阻止默认的回车行为 (例如表单提交)
                checkPassword(); // 调用解锁函数
            }
        });


        // 点击提示框外部区域关闭提示框
        document.addEventListener('click', (e) => {
            // 检查：1.提示框是否可见； 2.点击位置是否在提示框内部； 3.点击位置是否在任何节点内部。
            // 如果提示框可见，且点击位置不在提示框和任何节点内部，则关闭提示框。
            // 使用 e.target.closest('.tooltip') 和 e.target.closest('.node') 更准确
             if (tooltip.style.display === 'block' &&
                 !e.target.closest('.tooltip') &&
                 !e.target.closest('.node'))
            {
                tooltip.style.display = 'none'; // 隐藏提示框
                currentNodeIndex = null; // 重置当前节点索引
                errorMsg.textContent = ''; // 清空错误信息
            }
        });

         // 页面加载完成后，初始化
         positionNodes(); // 定位 HTML 节点
         createSegmentPaths(); // 创建 SVG 段路径并设置初始状态


         // 注意：根据您的要求，此处没有添加窗口 resize 事件监听，不做全屏适配。

    </script>
</body>
</html>