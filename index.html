<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>环形进度系统</title>
    <style>
        /* 深色模式基础样式 */
        body {
            margin: 0;
            padding: 0;
            background: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
            overflow: hidden; /* 防止滚动条出现 */
            display: flex; /* 使用 flexbox 将内容居中 */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* 确保body至少占满视口高度 */
        }
        /* 圆环容器，固定大小并居中 */
        .ring-container {
            position: relative; /* 允许子元素绝对定位 */
            width: 600px; /* 固定宽度 */
            height: 600px; /* 固定高度 */
            /* flexbox 已处理居中 */
        }
        /* 主圆环样式 */
        .main-ring {
            position: absolute;
            width: 100%; /* 占满父容器 (ring-container) */
            height: 100%; /* 占满父容器 */
            border: 2px solid #cc0000; /* 细边框，深红色 */
            border-radius: 50%;
            top: 0;
            left: 0;
        }
        /* 进度环 SVG 容器 */
        .progress-svg {
            position: absolute;
            width: 100%; /* 占满父容器 */
            height: 100%; /* 占满父容器 */
            top: 0;
            left: 0;
            /* viewBox="0 0 600 600" 在 SVG 标签上 */
            overflow: visible; /* 防止路径的stroke-linecap在边界被裁切 */
        }
        /* SVG 进度路径样式 */
        .progress-path {
            fill: none; /* 不填充区域 */
            stroke: #66ccff; /* 浅蓝色描边 */
            stroke-width: 4px; /* 描边宽度 */
            stroke-linecap: round; /* 使描边端点圆润 */
            /* stroke-dashoffset 属性的过渡动画 */
            transition: stroke-dashoffset 2s ease-in-out; /* 动画时间设置为 2000ms (2秒) */
            /* stroke-dasharray 和 stroke-dashoffset 由 JavaScript 控制实现动画 */
        }

        /* 节点基础样式 */
        .node {
            position: absolute;
            /* top/left 将由JavaScript精确计算设置 */
            cursor: pointer; /* 鼠标悬停显示手型 */
            z-index: 2; /* 放在圆环上方 */
            text-align: center; /* 文本居中 */
            box-sizing: border-box; /* 边框和内边距包含在元素的 width/height 内 */
            border: 2px solid #ffffff; /* 白色边框 */
             transition: background 0.3s ease, border-color 0.3s ease; /* 添加背景和边框颜色动画 */
        }
        /* 节点尺寸 */
        .node.diamond, .node.square, .center-node {
             width: 40px;
             height: 40px;
        }
        /* 菱形节点样式（索引0） */
        .node.diamond {
            background: #ffffff; /* 默认白色背景 */
            /* transform 会在 JS 设置 top/left 后应用 */
        }
        /* 正方形节点样式 */
        .node.square {
            background: #333; /* 未解锁时为深色背景 */
             /* transform 会在 JS 设置 top/left 后应用 */
        }

        /* 中间节点样式（索引6） */
        .center-node {
            width: 60px;
            height: 60px;
            background: #333; /* 未启用时为深色背景 */
            opacity: 0.5; /* 半透明 */
            pointer-events: none; /* 默认不可点击 */
            display: flex; /* 使文字居中 */
            justify-content: center; /* 文字水平居中 */
            align-items: center; /* 文字垂直居中 */
            font-size: 14px; /* 文字大小 */
            color: #ffffff; /* 文字颜色 */
            /* transform 会在 JS 设置 top/left 后应用 */
             transition: opacity 0.3s ease, background 0.3s ease, color 0.3s ease, pointer-events 0.3s ease; /* 添加状态变化动画 */
        }

        /* 解锁节点样式 */
        .node.unlocked.diamond {
             background: #66ccff; /* 菱形解锁后也变为浅蓝色 */
             border-color: #66ccff; /* 边框颜色也变 */
        }
         .node.unlocked.square {
             background: #66ccff; /* 正方形解锁后变为浅蓝色背景 */
             border-color: #66ccff; /* 边框颜色也变 */
        }
        .center-node.enabled {
             opacity: 1; /* 完全不透明 */
             pointer-events: auto; /* 启用后可点击 */
             background: #ffffff; /* 启用后背景变白色 */
             color: #121212; /* 启用后文字变深色 */
        }

        /* 提示框样式 */
        .tooltip {
            position: fixed; /* 固定在视口中 */
            right: 20px; /* 距离右侧 20px */
            top: 20px; /* 距离顶部 20px */
            width: 300px; /* 固定宽度 */
            height: 80vh; /* 高度为视口高度的 80% */
            background: #1e1e1e; /* 深色背景 */
            border: 2px solid #ffffff; /* 白色边框 */
            overflow-y: auto; /* 垂直方向允许滚动 */
            padding: 10px; /* 内边距 */
            box-sizing: border-box; /* 边框和内边距包含在 width/height 内 */
            display: none; /* 默认隐藏 */
            z-index: 3; /* 放在最顶层 */
            color: #cccccc; /* 文字颜色 */
        }

        /* 密码输入区域 */
        .password-form {
            position: sticky; /* 尝试固定在滚动区域底部，兼容性需注意 */
            bottom: 0; /* 固定在底部 */
            background: #1e1e1e; /* 与提示框背景一致 */
            padding: 10px 0 0 0; /* 上边距，左右下无内边距 */
            margin: 0; /* 无外边距 */
            width: 100%; /* 占满父容器宽度 */
            box-sizing: border-box;
        }
        .password-form input[type="password"] {
            width: calc(100% - 18px); /* 调整宽度以适应内边距和边框 */
            padding: 8px; /* 内边距 */
            margin-bottom: 5px; /* 下边距 */
            box-sizing: border-box;
            background: #333; /* 输入框背景色 */
            color: white; /* 文字颜色 */
            border: 1px solid #666; /* 边框颜色 */
            display: block; /* 使元素独占一行 */
        }
        .password-form button {
            width: 100%; /* 占满父容器宽度 */
            padding: 8px; /* 内边距 */
            background: #4CAF50; /* 背景绿色 */
            color: white; /* 文字白色 */
            border: none; /* 无边框 */
            cursor: pointer; /* 鼠标悬停显示手型 */
            display: block; /* 使元素独占一行 */
             transition: background 0.3s ease; /* 背景颜色变化动画 */
        }
        .password-form button:hover {
            background: #45a049; /* 鼠标悬停背景变深 */
        }
        .error {
            color: red; /* 文字红色 */
            text-align: center; /* 文字居中 */
            margin-top: 5px; /* 上边距 */
            font-size: 0.9em; /* 文字大小 */
        }
        #tooltipContent {
            margin-bottom: 20px; /* 在内容和密码表单之间留白 */
             word-wrap: break-word; /* 防止长文本溢出 */
             white-space: pre-wrap; /* 保留换行符，使说明文字格式更灵活 */
        }
         .tooltip p {
             margin: 0 0 10px 0; /* 段落下边距 */
             line-height: 1.5; /* 行高 */
         }
    </style>
</head>
<body>
    <div class="ring-container">
        <!-- 主圆环 -->
        <div class="main-ring"></div>
        <!-- 进度环 SVG -->
        <svg class="progress-svg" viewBox="0 0 600 600">
            <!-- viewBox="0 0 600 600" 定义了 SVG 的内部坐标系范围，圆心在 300, 300 -->
            <!-- 进度路径，由JavaScript动态生成 d 属性 -->
            <path id="progressPath" class="progress-path"/>
        </svg>
        <!-- 节点组 -->
        <div class="nodes">
            <!-- 节点的位置和 transform 将通过 JavaScript 精确计算并设置 style -->
            <!-- data-index 0: 菱形, 底部 (解锁顺序起点) -->
            <div class="node diamond" data-index="0"></div>
            <!-- data-index 1-5: 正方形, 顺时针排列 -->
            <div class="node square" data-index="1"></div>
            <div class="node square" data-index="2"></div>
            <div class="node square" data-index="3"></div>
            <div class="node square" data-index="4"></div>
            <div class="node square" data-index="5"></div>

            <!-- 中间节点 (索引6) -->
            <div class="node center-node" id="centerNode" data-index="6">
                中心
            </div>
        </div>
    </div>
    <!-- 提示框 -->
    <div class="tooltip" id="tooltip">
        <div id="tooltipContent">这里是节点说明文字...</div>
        <div class="password-form" id="passwordForm">
            <input type="password" id="passwordInput" placeholder="请输入密码">
            <button id="unlockButton">解锁</button>
            <div class="error" id="errorMsg"></div>
        </div>
    </div>
    <script>
        // ========== 可配置参数 ==========
        const nodeDescriptions = [
            "这是位于最下方的菱形节点，它是整个系统的起点。\n它无需密码即可查看说明。",   // 节点0 (菱形)
            "这是解锁序列的第一个正方形节点。\n解锁它将开启系统。\n提示：密码是 node1pass", // 节点1
            "这是解锁序列的第二个正方形节点。\n提示：密码是 node2pass",       // 节点2
            "这是解锁序列的第三个正方形节点。\n提示：密码是 node3pass",       // 节点3
            "这是解锁序列的第四个正方形节点。\n提示：密码是 node4pass",       // 节点4
            "这是解锁序列的第五个正方形节点。\n解锁它将开启中心节点。\n提示：密码是 node5pass", // 节点5
            "恭喜！你已解锁所有环形节点。这是中心节点。\n在所有环形节点解锁后，输入密码即可访问下一阶段。\n提示：密码是 centerpass"  // 节点6 (中心) - 更新了描述
        ];
        const nodePasswords = [
            "",                     // 节点0 (菱形) 无需密码解锁
            "node1pass",            // 节点1 密码
            "node2pass",            // 节点2 密码
            "node3pass",            // 节点3 密码
            "node4pass",            // 节点4 密码
            "node5pass",            // 节点5 密码
            "centerpass"            // 节点6 (中心) 密码
        ];

        // 节点在圆环上的角度 (从右侧0度开始，逆时针为正)
        // 根据“菱形在最下方”和“顺时针解锁”的要求重新定义角度：
        // 节点0 (底部菱形): 90度 (Math/JS角度，对应SVG底部)
        // 节点1 (右下正方): 90 - 60 = 30度
        // 节点2 (右上正方): 30 - 60 = -30度 (或 330度)
        // 节点3 (顶部正方): 330 - 60 = 270度
        // 节点4 (左上正方): 270 - 60 = 210度
        // 节点5 (左下正方): 210 - 60 = 150度
        const nodeAngles = [90, 30, 330, 270, 210, 150]; // 节点0-5 对应角度 (从右侧0度逆时针为正 Math/JS 角度)

        // ========== 配置结束 ==========

        // 获取DOM元素
        const nodes = document.querySelectorAll('.node');
        const tooltip = document.getElementById('tooltip');
        const tooltipContent = document.getElementById('tooltipContent');
        const passwordForm = document.getElementById('passwordForm');
        const passwordInput = document.getElementById('passwordInput');
        const unlockButton = document.getElementById('unlockButton');
        const errorMsg = document.getElementById('errorMsg');
        const centerNode = document.getElementById('centerNode');
        const progressPath = document.getElementById('progressPath'); // 获取 path 元素


        // unlockedNodes[i] 为 true 表示索引 i 的节点 (0-5) 已解锁
        // 节点0 (菱形) 默认解锁，作为起点
        let unlockedNodes = [true, false, false, false, false, false]; // 节点0-5 的解锁状态
        let isCenterEnabled = false; // 中心节点默认锁定
        let currentNodeIndex = null; // 当前选中的节点索引 (0-6)

        // 圆的参数 (基于 600x600 的 SVG viewBox)
        const radius = 300;
        const circleCenterX = 300; // SVG 内部坐标系中的圆心 X 坐标 (也是ring-container的中心)
        const circleCenterY = 300; // SVG 内部坐标系中的圆心 Y 坐标 (也是ring-container的中心)
        const circumference = 2 * Math.PI * radius; // 圆周长


        // --- 初始化设置 ---

        // 1. 精确定位节点
        positionNodes();

        // 2. 初始化进度条路径 (长度为0，起点在底部)
        updateProgress(); // 绘制初始路径并设置动画初始状态

        // 3. 标记菱形节点 (node 0) 为视觉上的解锁/起点状态
        nodes[0].classList.add('unlocked');


        // --- 函数定义 ---

        /**
         * 根据 Math/JS 角度计算节点在圆环上的 SVG 坐标 (也就是相对于 ring-container 左上角的坐标)
         * Math/JS 角度: 0度在右，逆时针为正
         * SVG 坐标系: 原点在左上角，Y轴向下为正
         * @param {number} angleDeg Math/JS 角度
         * @returns {{x: number, y: number}} 返回 SVG 坐标 (相对于 SVG 左上角 0,0)
         */
        function calculateNodeSvgPosition(angleDeg) {
             // 将角度转换为弧度
             const angleRad = angleDeg * Math.PI / 180;

             // 计算相对于圆心的坐标，然后加上圆心坐标 (圆心在 SVG 的 300, 300)
             const nodeX = circleCenterX + radius * Math.cos(angleRad);
             const nodeY = circleCenterY + radius * Math.sin(angleRad);

             return { x: nodeX, y: nodeY };
        }


        // 根据计算出的 SVG 坐标定位 HTML 节点元素
        function positionNodes() {
            // 节点的 top/left 设置为 SVG 坐标，然后通过 translate(-50%, -50%) 将节点自身中心对齐到该点
            // ring-container 就是 SVG 的绘制区域，其左上角 (0,0) 对应 SVG 的 (0,0)
            nodes.forEach(node => {
                const index = parseInt(node.dataset.index);
                if (index === 6) { // 中心节点
                    // 中心节点通过 CSS position: 50% 50% 和 transform: translate(-50%, -50%) 居中
                    // 这里的 50% 是相对于父容器 ring-container 的
                    node.style.left = '50%';
                    node.style.top = '50%';
                    node.style.transform = 'translate(-50%, -50%)';
                    return;
                }

                // 获取当前节点的 Math/JS 角度
                const angleDeg = nodeAngles[index];
                // 计算节点在 SVG 坐标系中的位置 (相对于 SVG 左上角)，也就是相对于 ring-container 左上角的位置
                const svgPos = calculateNodeSvgPosition(angleDeg);

                // 设置节点的 top/left 属性
                node.style.top = `${svgPos.y}px`;
                node.style.left = `${svgPos.x}px`;

                // 添加 transform 用于元素自身居中 和 形状旋转 (对于菱形)
                if (node.classList.contains('diamond')) {
                     // 菱形需要额外的 45度旋转才能在定位后看起来是菱形
                     node.style.transform = `translate(-50%, -50%) rotate(45deg)`;
                } else {
                     // 正方形只需自身居中
                     node.style.transform = `translate(-50%, -50%)`;
                }
            });
        }


        // 显示提示框
        function showTooltip(needsPassword) {
            if (currentNodeIndex === null) return;

            tooltip.style.display = 'block'; // 显示提示框
            tooltipContent.textContent = nodeDescriptions[currentNodeIndex]; // 设置提示内容
            errorMsg.textContent = ''; // 清空之前的错误信息

            if (needsPassword) {
                passwordForm.style.display = 'block'; // 显示密码输入区域
                passwordInput.value = ''; // 清空密码输入框
                 // 根据节点类型设置解锁按钮文本
                 unlockButton.textContent = currentNodeIndex === 6 ? '进入' : '解锁';
            } else {
                passwordForm.style.display = 'none'; // 隐藏密码输入区域
            }

            tooltip.scrollTop = 0; // 显示提示框时滚动到顶部
        }

        // 检查密码并处理解锁
        function checkPassword() {
            if (currentNodeIndex === null) return;

            const input = passwordInput.value;
            // 检查输入的密码是否与当前节点的密码匹配
            if (input === nodePasswords[currentNodeIndex]) {
                errorMsg.textContent = ''; // 清空错误信息
                tooltip.style.display = 'none'; // 隐藏提示框

                if (currentNodeIndex >= 1 && currentNodeIndex <= 5) {
                    // 解锁环形节点 (1-5)
                    unlockedNodes[currentNodeIndex] = true; // 更新解锁状态数组
                    nodes[currentNodeIndex].classList.add('unlocked'); // 给节点添加视觉反馈类 (变色)
                    updateProgress(); // 更新进度条路径并触发动画

                    // 检查是否所有环形节点 (1-5) 都已解锁
                    let allRingNodesUnlocked = true;
                    for(let i = 1; i <= 5; i++) {
                        if (!unlockedNodes[i]) {
                            allRingNodesUnlocked = false;
                            break;
                        }
                    }
                    // 如果所有环形节点 (1-5) 都已解锁，则启用中心节点
                    if (allRingNodesUnlocked) {
                        enableCenterNode();
                    }
                } else if (currentNodeIndex === 6 && isCenterEnabled) {
                    // 已启用中心节点且密码正确 - 执行下一步操作 (例如页面跳转)
                    alert("中心节点解锁成功！即将进入下一阶段..."); // 示例弹窗
                    // window.location.href = 'next.html'; // 示例页面跳转
                }

                 currentNodeIndex = null; // 操作成功后重置当前节点索引
            } else {
                errorMsg.textContent = '密钥错误！'; // 显示错误信息
                passwordInput.value = ''; // 清空输入框，方便重新输入
            }
        }

        // 更新进度条路径和动画
        function updateProgress() {
            // 查找最后一个已解锁的环形节点 (从索引 5 倒序查找)
            let lastUnlockedIndex = 0; // 默认是节点 0 (底部菱形)
            for(let i = 5; i >= 1; i--) {
                if (unlockedNodes[i]) {
                    lastUnlockedIndex = i;
                    break; // 找到第一个已解锁的环形节点 (索引 1-5) 就停止查找
                }
            }

            // 进度条的起点是 Node 0 (底部菱形) 的位置
            const startPos = calculateNodeSvgPosition(nodeAngles[0]); // 节点0 (底部 90度 Math/JS) 的 SVG 坐标
            const startX = startPos.x;
            const startY = startPos.y;

            // 进度条的终点是最后一个已解锁的环形节点位置
            const endPos = calculateNodeSvgPosition(nodeAngles[lastUnlockedIndex]); // 最后一个已解锁节点 (0-5) 的 SVG 坐标
            const endX = endPos.x;
            const endY = endPos.y;

            // 构建 SVG Path 的 'd' 属性字符串
            let pathData;
            if (lastUnlockedIndex === 0) {
                 // 如果只解锁了节点0，路径是一个点 (或很短的线段)，表示无进度
                 // 为了防止 getTotalLength() 返回 0 导致动画异常，画一条很短的线
                 pathData = `M ${startX} ${startY} L ${startX + 0.001} ${startY}`;
            } else {
                 // 绘制圆弧的参数
                 const sweepFlag = 0; // 0 表示顺时针方向绘制

                 // large-arc-flag: 1 表示使用大于180度的大圆弧，0 表示使用小于180度的小圆弧
                 // 从底部节点 0 (Math/JS 90度) 顺时针到最后一个解锁节点
                 // 需要计算顺时针角度差是否 >= 180度
                 // 节点索引 0, 1, 2 对应的顺时针角度差是 0, 60, 120 度 (相对于节点0) -> 小圆弧 (large-arc-flag=0)
                 // 节点索引 3, 4, 5 对应的顺时针角度差是 180, 240, 300 度 (相对于节点0) -> 大圆弧 (large-arc-flag=1)
                 const largeArcFlag = lastUnlockedIndex >= 3 ? 1 : 0;

                 // M x y: 移动到 (x, y)
                 // A rx ry x-axis-rotation large-arc-flag sweep-flag x y: 绘制圆弧到 (x, y)
                 pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`;
            }

            // 设置 path 元素的 d 属性
            progressPath.setAttribute('d', pathData);

            // 实现路径绘制动画 (从隐藏到显示)
            // 获取当前绘制路径的实际长度
            // 注意：getTotalLength() 必须在设置了 d 属性之后调用
            const pathLength = progressPath.getTotalLength();

            // 设置 stroke-dasharray 使虚线段的长度等于路径总长
            progressPath.style.strokeDasharray = pathLength;
            // 将 stroke-dashoffset 设置为路径总长，使描边完全偏移到路径末端，从而隐藏描边
            // 这是动画的起点
            progressPath.style.strokeDashoffset = pathLength;

            // 使用 requestAnimationFrame 确保浏览器在下次重绘前应用 stroke-dashoffset 的初始值 (pathLength)
            // 然后在下一个渲染周期将 stroke-dashoffset 设置为 0，触发 CSS transition 动画
            // 双重 requestAnimationFrame 是为了确保浏览器有时间在设置动画终点前渲染初始状态
             requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    // 如果 pathLength 接近 0，直接设置为 pathLength，避免动画
                    progressPath.style.strokeDashoffset = (pathLength > 0.1) ? 0 : pathLength; // 动画到 0，显示整条路径
                });
             });

             // CSS 中已经设置了 transition: stroke-dashoffset 2s ease-in-out; 来控制动画时间和缓动函数
        }

        // 启用中心节点 (解锁后状态)
        function enableCenterNode() {
            isCenterEnabled = true; // 标记中心节点为已启用
            centerNode.classList.add('enabled'); // 给中心节点添加视觉反馈类 (变色，可点击)
            console.log("中心节点已解锁！"); // 控制台输出提示
        }

        // --- 事件监听 ---

        // 给所有节点 (0-6) 添加点击监听
        nodes.forEach(node => {
            const index = parseInt(node.dataset.index); // 获取节点索引

            node.addEventListener('click', (e) => {
                 e.stopPropagation(); // 阻止点击事件冒泡，防止点击节点时同时触发 document 的点击事件关闭提示框

                 if (index === 6) { // 中心节点 (索引6) 的特殊处理
                     // 中心节点即使未启用也可以点击查看描述
                     currentNodeIndex = index;
                     // 如果中心节点已启用 (isCenterEnabled 为 true)，点击需要密码以执行功能 (showTooltip(true))；
                     // 如果未启用，只显示描述 (showTooltip(false))，无需密码输入框。
                     showTooltip(isCenterEnabled);
                     return; // 中心节点处理完毕，退出循环
                 }

                 // 对于环形节点 (0-5) 的处理
                 if (index === 0) {
                    // 节点0 (菱形) 是起点，始终可点击查看信息，无需密码输入框
                    currentNodeIndex = index;
                    showTooltip(false); // 显示节点0的描述，不显示密码输入区域
                 } else { // 环形节点 1-5: 需要按顺序解锁
                    // 检查上一个节点 (索引 index - 1) 是否已解锁 (在 unlockedNodes 数组中)
                    // 注意：节点0 索引是 0, 对应解锁状态数组的 0
                    // 节点1 索引是 1, 对应解锁状态数组的 1, 前一个节点是 0
                    // 节点2 索引是 2, 对应解锁状态数组的 2, 前一个节点是 1
                    // ...
                    // 节点5 索引是 5, 对应解锁状态数组的 5, 前一个节点是 4
                    if (!unlockedNodes[index - 1]) {
                        alert("请按顺序解锁前一个节点！"); // 弹出提示
                        return; // 如果前一个未解锁，阻止进一步操作
                    }

                    // 如果当前节点 (索引 index) 已解锁，只显示信息，无需密码输入框
                    if (unlockedNodes[index]) {
                        currentNodeIndex = index;
                        showTooltip(false); // 显示当前节点的描述，不显示密码输入区域
                    } else {
                         // 当前节点未解锁，且前一个已解锁，显示提示框并要求输入密码
                         currentNodeIndex = index;
                         showTooltip(true); // 显示当前节点的描述，并显示密码输入区域
                    }
                 }
            });
        });

        // 解锁按钮点击事件处理函数
        unlockButton.addEventListener('click', checkPassword);

        // 监听密码输入框回车事件
        passwordInput.addEventListener('keypress', function(event) {
            // 检查是否按下回车键 (event.key === 'Enter' 是现代方法)
            if (event.key === 'Enter') {
                event.preventDefault(); // 阻止默认的回车行为 (例如表单提交)
                checkPassword(); // 调用解锁函数
            }
        });


        // 点击提示框外部区域关闭提示框
        document.addEventListener('click', (e) => {
            // 检查：1.提示框是否可见； 2.点击位置是否在提示框内部； 3.点击位置是否在任何节点内部。
            // 如果提示框可见，且点击位置不在提示框和任何节点内部，则关闭提示框。
            if (tooltip.style.display === 'block' &&
                !tooltip.contains(e.target) &&
                !e.target.closest('.node')) // closest() 检查元素本身或其任何父级是否匹配选择器
            {
                tooltip.style.display = 'none'; // 隐藏提示框
                currentNodeIndex = null; // 重置当前节点索引
                errorMsg.textContent = ''; // 清空错误信息
            }
        });

         // 页面加载完成后，初始化节点位置
         positionNodes();
         // 第一次加载时，进度条只画到节点0（点），会触发一次动画（虽然看不到）
         updateProgress();


         // 注意：根据您的要求，此处没有添加窗口 resize 事件监听，不做全屏适配。

    </script>
</body>
</html>