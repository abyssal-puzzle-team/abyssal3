<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>环形进度系统</title>
    <style>
        /* 深色模式基础样式 */
        body {
            margin: 0;
            padding: 0;
            background: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
            overflow: hidden; /* 防止滚动条出现 */
            display: flex; /* 使用 flexbox 将内容居中 */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* 确保body至少占满视口高度 */
        }
        /* 圆环容器，固定大小并居中 */
        .ring-container {
            position: relative; /* 允许子元素绝对定位 */
            width: 600px; /* 固定宽度 */
            height: 600px; /* 固定高度 */
            /* flexbox 已处理居中 */
        }
        /* 主圆环样式 - 根据视频，外圈圆环不是很明显，可以稍微调整样式或透明度 */
        .main-ring {
            position: absolute;
            width: 100%; /* 占满父容器 (ring-container) */
            height: 100%; /* 占满父容器 */
            /* 视频中外圈不突出，可以降低透明度或颜色 */
            border: 2px solid rgba(204, 0, 0, 0.3); /* 细边框，深红色，半透明 */
            border-radius: 50%;
            top: 0;
            left: 0;
        }
        /* 进度环 SVG 容器 */
        .progress-svg {
            position: absolute;
            width: 100%; /* 占满父容器 */
            height: 100%; /* 占满父容器 */
            top: 0;
            left: 0;
            /* viewBox="0 0 600 600" 在 SVG 标签上 */
            overflow: visible; /* 防止路径的stroke-linecap在边界被裁切 */
        }
        /* SVG 段路径样式 */
        .segment-path {
            fill: none; /* 不填充区域 */
            stroke: #66ccff; /* 浅蓝色描边 */
            stroke-width: 4px; /* 描边宽度 */
            stroke-linecap: round; /* 使描边端点圆润 */
            /* 初始隐藏，动画会改变 stroke-dashoffset */
            opacity: 0; /* 初始不可见 */
            transition: none; /* 移除 stroke-dashoffset 的 CSS transition */
        }

        /* 移动的点样式 */
        .traveling-dot {
            fill: #ffffff; /* 点的颜色 */
            r: 4px; /* 点的半径 */
            display: none; /* 初始隐藏 */
        }


        /* 节点基础样式 */
        .node {
            position: absolute;
            /* top/left 将由JavaScript精确计算设置 */
            cursor: pointer; /* 鼠标悬停显示手型 */
            z-index: 2; /* 放在圆环上方 */
            text-align: center; /* 文本居中 */
            box-sizing: border-box; /* 边框和内边距包含在元素的 width/height 内 */
            border: 2px solid #ffffff; /* 白色边框 */
             transition: background 0.3s ease, border-color 0.3s ease; /* 添加背景和边框颜色动画 */
        }
        /* 节点尺寸 */
        .node.diamond, .node.square, .center-node {
             width: 40px;
             height: 40px;
        }
        /* 菱形节点样式（索引0） */
        .node.diamond {
            background: #ffffff; /* 默认白色背景 */
            /* transform 会在 JS 设置 top/left 后应用 */
        }
        /* 正方形节点样式 */
        .node.square {
            background: #333; /* 未解锁时为深色背景 */
             /* transform 会在 JS 设置 top/left 后应用 */
        }

        /* 中间节点样式（索引6） */
        .center-node {
            width: 60px;
            height: 60px;
            background: #333; /* 未启用时为深色背景 */
            opacity: 0.5; /* 半透明 */
            pointer-events: none; /* 默认不可点击 */
            display: flex; /* 使文字居中 */
            justify-content: center; /* 文字水平居中 */
            align-items: center; /* 文字垂直居中 */
            font-size: 14px; /* 文字大小 */
            color: #ffffff; /* 文字颜色 */
            /* transform 会在 JS 设置 top/left 后应用 */
             transition: opacity 0.3s ease, background 0.3s ease, color 0.3s ease, pointer-events 0.3s ease; /* 添加状态变化动画 */
        }

        /* 解锁节点样式 */
        .node.unlocked.diamond,
        .node.unlocked.square {
             background: #66ccff; /* 解锁后变为浅蓝色 */
             border-color: #66ccff; /* 边框颜色也变 */
        }
        .center-node.enabled {
             opacity: 1; /* 完全不透明 */
             pointer-events: auto; /* 启用后可点击 */
             background: #ffffff; /* 启用后背景变白色 */
             color: #121212; /* 启用后文字变深色 */
        }

        /* 提示框样式 */
        .tooltip {
            position: fixed; /* 固定在视口中 */
            right: 20px; /* 距离右侧 20px */
            top: 20px; /* 距离顶部 20px */
            width: 300px; /* 固定宽度 */
            height: 80vh; /* 高度为视口高度的 80% */
            background: #1e1e1e; /* 深色背景 */
            border: 2px solid #ffffff; /* 白色边框 */
            overflow-y: auto; /* 垂直方向允许滚动 */
            padding: 10px; /* 内边距 */
            box-sizing: border-box; /* 边框和内边距包含在 width/height 内 */
            display: none; /* 默认隐藏 */
            z-index: 3; /* 放在最顶层 */
            color: #cccccc; /* 文字颜色 */
        }

        /* 密码输入区域 */
        .password-form {
            position: sticky; /* 尝试固定在滚动区域底部，兼容性需注意 */
            bottom: 0; /* 固定在底部 */
            background: #1e1e1e; /* 与提示框背景一致 */
            padding: 10px 0 0 0; /* 上边距，左右下无内边距 */
            margin: 0; /* 无外边距 */
            width: 100%; /* 占满父容器宽度 */
            box-sizing: border-box;
        }
        /* 针对新的 type="text" 输入框应用样式 */
        .password-form input[type="text"] {
            width: calc(100% - 18px); /* 调整宽度以适应内边距和边框 */
            padding: 8px; /* 内边距 */
            margin-bottom: 5px; /* 下边距 */
            box-sizing: border-box;
            background: #333; /* 输入框背景色 */
            color: white; /* 文字颜色 */
            border: 1px solid #666; /* 边框颜色 */
            display: block; /* 使元素独占一行 */
        }
        .password-form button {
            width: 100%; /* 占满父容器宽度 */
            padding: 8px; /* 内边距 */
            background: #4CAF50; /* 背景绿色 */
            color: white; /* 文字白色 */
            border: none; /* 无边框 */
            cursor: pointer; /* 鼠标悬停显示手型 */
            display: block; /* 使元素独占一行 */
             transition: background 0.3s ease; /* 背景颜色变化动画 */
        }
        .password-form button:not(:disabled):hover { /* 鼠标悬停效果只在非禁用状态下显示 */
            background: #45a049; /* 鼠标悬停背景变深 */
        }
         .password-form button:disabled {
             background: #666; /* 禁用时背景变灰 */
             cursor: not-allowed; /* 禁用时鼠标变禁止符号 */
         }
        .error {
            color: red; /* 文字红色 */
            text-align: center; /* 文字居中 */
            margin-top: 5px; /* 上边距 */
            font-size: 0.9em; /* 文字大小 */
        }
        #tooltipContent {
            margin-bottom: 20px; /* 在内容和密码表单之间留白 */
             word-wrap: break-word; /* 防止长文本溢出 */
             white-space: pre-wrap; /* 保留换行符，使说明文字格式更灵活 */
        }
         .tooltip p {
             margin: 0 0 10px 0; /* 段落下边距 */
             line-height: 1.5; /* 行高 */
         }
    </style>
</head>
<body>
    <div class="ring-container">
        <!-- 主圆环 -->
        <div class="main-ring"></div>
        <!-- 进度环 SVG -->
        <svg class="progress-svg" viewBox="0 0 600 600">
            <!-- SVG 内部坐标系范围，圆心在 300, 300 -->
            <!-- 段路径，由JavaScript动态生成并控制显隐和动画 -->
            <!-- 将段路径放在点的前面，确保点绘制在路径上方 -->
            <path id="segmentPath-0-1" class="segment-path"/>
            <path id="segmentPath-1-2" class="segment-path"/>
            <path id="segmentPath-2-3" class="segment-path"/>
            <path id="segmentPath-3-4" class="segment-path"/>
            <path id="segmentPath-4-5" class="segment-path"/>
            <!-- 新增从节点5到节点0的路径 -->
            <path id="segmentPath-5-0" class="segment-path"/>

            <!-- 移动的点 -->
            <circle id="travelingDot" class="traveling-dot"/>
        </svg>
        <!-- 节点组 -->
        <div class="nodes">
            <!-- 节点的位置和 transform 将通过 JavaScript 精确计算并设置 style -->
            <!-- data-index 对应解锁顺序： 0(菱形) -> 1 -> 2 -> 3 -> 4 -> 5 (正方形) -->
            <!-- HTML 元素的顺序应该与 data-index 一致，方便 JS 获取 -->

            <!-- data-index 0: 菱形, 底部 (解锁顺序起点) -->
            <div class="node diamond" data-index="0"></div>

             <!-- data-index 1: 正方形, 左下 (解锁顺序 1) -->
            <div class="node square" data-index="1"></div>

             <!-- data-index 2: 正方形, 左上 (解锁顺序 2) -->
            <div class="node square" data-index="2"></div>

             <!-- data-index 3: 正方形, 顶部 (解锁顺序 3) -->
            <div class="node square" data-index="3"></div>

             <!-- data-index 4: 正方形, 右上 (解锁顺序 4) -->
            <div class="node square" data-index="4"></div>

             <!-- data-index 5: 正方形, 右下 (解锁顺序 5) -->
            <div class="node square" data-index="5"></div>

            <!-- 中间节点 (索引6) -->
            <div class="node center-node" id="centerNode" data-index="6">
                中心
            </div>
        </div>
    </div>
    <!-- 提示框 -->
    <div class="tooltip" id="tooltip">
        <div id="tooltipContent">这里是节点说明文字...</div>
        <div class="password-form" id="passwordForm">
            <!-- 密码输入框，type="text" 以显示输入字符 -->
            <input type="text" id="passwordInput" placeholder="请输入密码">
            <button id="unlockButton">解锁</button>
            <div class="error" id="errorMsg"></div>
        </div>
    </div>
    <script>
        // ========== 可配置参数 ==========

        // 节点角度定义 (Math/JS 角度: 0=右, 90=下, 180=左, 270=上)
        // 顺序与解锁顺序一致： 0(底部菱形) -> 1(左下) -> 2(左上) -> 3(顶部) -> 4(右上) -> 5(右下)
        const nodeAngles = [90, 150, 210, 270, 330, 30]; // 6个环形节点角度

        const nodeDescriptions = [
            "这是位于最下方的菱形节点，它是整个系统的起点。\n它无需密码即可查看说明。",   // 节点0 (菱形, 底部)
            "这是解锁序列的第一个正方形节点 (左下)。\n解锁它将开启系统。\n提示：密码是 node1pass", // 节点1 (左下)
            "这是解锁序列的第二个正方形节点 (左上)。\n提示：密码是 node2pass",       // 节点2 (左上)
            "这是解锁序列的第三个正方形节点 (顶部)。\n提示：密码是 node3pass",       // 节点3 (顶部)
            "这是解锁序列的第四个正方形节点 (右上)。\n提示：密码是 node4pass",       // 节点4 (右上)
            "这是解锁序列的第五个正方形节点 (右下)。\n解锁它将开启中心节点。\n提示：密码是 node5pass", // 节点5 (右下)
            "恭喜！你已解锁所有环形节点。这是中心节点。\n在所有环形节点解锁后，输入密码即可访问下一阶段。\n提示：密码是 centerpass"  // 节点6 (中心)
        ];
        const nodePasswords = [
            "",                     // 节点0 (菱形) 无需密码解锁
            "node1pass",            // 节点1 (左下) 密码
            "node2pass",            // 节点2 (左上) 密码
            "node3pass",            // 节点3 (顶部) 密码
            "node4pass",            // 4 (右上) 密码
            "node5pass",            // 5 (右下) 密码
            "centerpass"            // 节点6 (中心) 密码
        ];

        const animationDuration = 2000; // 单段动画时长 (毫秒)
        const fullCircleAnimationDuration = 3000; // 解锁节点5时的整个圆环动画时长
        const cooldownDuration = 5; // 密码错误后的冷却时长 (秒)

        // ========== 配置结束 ==========

        // 获取DOM元素
        const nodes = document.querySelectorAll('.node');
        const tooltip = document.getElementById('tooltip');
        const tooltipContent = document.getElementById('tooltipContent');
        const passwordForm = document.getElementById('passwordForm');
        const passwordInput = document.getElementById('passwordInput'); // 已经是 type="text"
        const unlockButton = document.getElementById('unlockButton');
        const errorMsg = document.getElementById('errorMsg');
        const centerNode = document.getElementById('centerNode');
        const travelingDot = document.getElementById('travelingDot');

        const segmentPaths = [];
        for(let i = 0; i < 5; i++) {
            segmentPaths.push(document.getElementById(`segmentPath-${i}-${i+1}`));
        }
        segmentPaths.push(document.getElementById(`segmentPath-5-0`));

        let unlockedNodes = [true, false, false, false, false, false]; // 节点0-5 的解锁状态
        let isCenterEnabled = false; // 中心节点默认锁定
        let currentNodeIndex = null; // 当前选中的节点索引 (0-6)

        // 冷却状态变量
        let isCoolingDown = false;
        let remainingCooldownTime = 0; // 用于倒计时显示
        let cooldownTimerId = null; // 用于存储 setInterval 的 ID

        const radius = 300;
        const circleCenterX = 300;
        const circleCenterY = 300;

        // --- 初始化设置 ---
        positionNodes();
        createSegmentPaths();
        const startNodeElement = document.querySelector('.node[data-index="0"]');
        if (startNodeElement && startNodeElement.classList.contains('diamond')) {
             startNodeElement.classList.add('unlocked');
        }

        function calculateNodeSvgPosition(angleDeg) {
             const angleRad = angleDeg * Math.PI / 180;
             const nodeX = circleCenterX + radius * Math.cos(angleRad);
             const nodeY = circleCenterY + radius * Math.sin(angleRad);
             return { x: nodeX, y: nodeY };
        }

        function positionNodes() {
            nodes.forEach((node) => {
                const index = parseInt(node.dataset.index);
                if (index === 6) {
                    node.style.left = '50%';
                    node.style.top = '50%';
                    node.style.transform = 'translate(-50%, -50%)';
                    return;
                }
                const angleDeg = nodeAngles[index];
                const svgPos = calculateNodeSvgPosition(angleDeg);
                node.style.top = `${svgPos.y}px`;
                node.style.left = `${svgPos.x}px`;
                if (node.classList.contains('diamond')) {
                     node.style.transform = `translate(-50%, -50%) rotate(45deg)`;
                } else {
                     node.style.transform = `translate(-50%, -50%)`;
                }
            });
        }

        function createSegmentPaths() {
             for (let i = 0; i < 6; i++) {
                 let startNodeIndex, endNodeIndex;
                 if (i < 5) {
                     startNodeIndex = i;
                     endNodeIndex = i + 1;
                 } else {
                     startNodeIndex = 5;
                     endNodeIndex = 0;
                 }
                 const startPos = calculateNodeSvgPosition(nodeAngles[startNodeIndex]);
                 const endPos = calculateNodeSvgPosition(nodeAngles[endNodeIndex]);
                 const pathData = `M ${startPos.x} ${startPos.y} A ${radius} ${radius} 0 0 1 ${endPos.x} ${endPos.y}`;
                 const pathElement = segmentPaths[i];
                 pathElement.setAttribute('d', pathData);
                 const pathLength = pathElement.getTotalLength();
                 pathElement.style.strokeDasharray = pathLength;
                 pathElement.style.strokeDashoffset = pathLength;
                 pathElement.style.opacity = 0;
             }
        }

        // 结束冷却状态，恢复输入
        function endCooldown() {
            isCoolingDown = false;
            passwordInput.disabled = false;
            unlockButton.disabled = false;
            errorMsg.textContent = ''; // 清空错误信息
            passwordInput.value = ''; // 清空密码输入框
            // 恢复按钮文本到默认或根据当前节点状态
            unlockButton.textContent = currentNodeIndex === 6 ? '进入' : '解锁';
            console.log("Cooldown finished.");
            // 如果提示框仍然显示，确保输入框和按钮状态正确 (redundant but safe)
            if (tooltip.style.display === 'block' && passwordForm.style.display !== 'none') {
                 passwordInput.disabled = false;
                 unlockButton.disabled = false;
                 unlockButton.textContent = currentNodeIndex === 6 ? '进入' : '解锁';
            }
        }

        // 开始冷却倒计时
        function startCooldown() {
            isCoolingDown = true;
            passwordInput.disabled = true; // 禁用输入框
            unlockButton.disabled = true; // 禁用按钮
            remainingCooldownTime = cooldownDuration; // 设置初始倒计时时间
            unlockButton.textContent = '请等待...'; // 按钮显示等待提示

            // 清除任何现有的计时器，防止重复
            if (cooldownTimerId !== null) {
                clearInterval(cooldownTimerId);
            }

            // 启动每秒更新的计时器
            cooldownTimerId = setInterval(() => {
                remainingCooldownTime--;
                if (remainingCooldownTime > 0) {
                    errorMsg.textContent = `密钥错误！请等待 ${remainingCooldownTime}秒...`;
                } else {
                    clearInterval(cooldownTimerId); // 停止计时器
                    cooldownTimerId = null; // 重置 ID
                    endCooldown(); // 调用结束冷却函数
                }
            }, 1000); // 每1000毫秒 (1秒) 执行一次
             // 显示初始错误信息（在第一次倒计时更新前）
             errorMsg.textContent = `密钥错误！请等待 ${remainingCooldownTime}秒...`;
        }


        // 显示提示框
        function showTooltip(needsPassword) {
            if (currentNodeIndex === null) return;

            tooltip.style.display = 'block';
            tooltipContent.textContent = nodeDescriptions[currentNodeIndex];
            passwordInput.value = ''; // 始终清空密码输入框的值
            errorMsg.textContent = ''; // 默认清空错误信息

            if (needsPassword) {
                passwordForm.style.display = 'block';
                if (isCoolingDown) {
                    // 如果当前正在冷却中，显示冷却信息和剩余时间
                    passwordInput.disabled = true;
                    unlockButton.disabled = true;
                    unlockButton.textContent = '请等待...';
                    // 错误信息由 startCooldown 的计时器负责更新
                    errorMsg.textContent = `密钥错误！请等待 ${remainingCooldownTime}秒...`;
                } else {
                    // 不在冷却中，启用输入和按钮
                    passwordInput.disabled = false;
                    unlockButton.disabled = false;
                    unlockButton.textContent = currentNodeIndex === 6 ? '进入' : '解锁';
                    errorMsg.textContent = ''; // 确保没有残留的冷却信息
                }
            } else {
                passwordForm.style.display = 'none'; // 无需密码则隐藏表单
                 // 如果之前在冷却，隐藏表单时也停止计时器（可选，取决于需求）
                 if (cooldownTimerId !== null) {
                     clearInterval(cooldownTimerId);
                     cooldownTimerId = null;
                     isCoolingDown = false; // 重置状态
                     remainingCooldownTime = 0; // 重置时间
                 }
            }

            tooltip.scrollTop = 0;
        }

        // 检查密码并处理解锁
        function checkPassword() {
            // 如果正在冷却，阻止新的尝试
            if (isCoolingDown) {
                console.log("System is in cooldown. Please wait.");
                 // 错误信息已经在倒计时中，无需重复设置
                return;
            }

            if (currentNodeIndex === null) return;

            const input = passwordInput.value;

            if (input === nodePasswords[currentNodeIndex]) {
                // --- 密码正确 ---
                errorMsg.textContent = ''; // 清空错误信息
                tooltip.style.display = 'none'; // 隐藏提示框

                // 如果之前在冷却，正确输入后停止计时器
                if (cooldownTimerId !== null) {
                    clearInterval(cooldownTimerId);
                    cooldownTimerId = null;
                    isCoolingDown = false;
                    remainingCooldownTime = 0;
                     // 确保输入框和按钮恢复正常状态
                    passwordInput.disabled = false;
                    unlockButton.disabled = false;
                }


                if (currentNodeIndex >= 1 && currentNodeIndex <= 5) {
                    // 解锁环形节点 (1-5)
                    if (!unlockedNodes[currentNodeIndex]) {
                         unlockedNodes[currentNodeIndex] = true;
                         const targetNode = document.querySelector(`.node[data-index="${currentNodeIndex}"]`);
                         if (targetNode) {
                              targetNode.classList.add('unlocked');
                         }

                         if (currentNodeIndex === 5) {
                             animatePathSegment(4, () => {
                                 animatePathSegment(5, () => {
                                     segmentPaths.forEach(pathElement => {
                                         pathElement.style.opacity = 1;
                                         pathElement.style.stroke = '#66ccff';
                                         pathElement.style.strokeDashoffset = 0;
                                     });
                                     let allRingNodesUnlocked = true;
                                     for(let i = 1; i <= 5; i++) {
                                         if (!unlockedNodes[i]) {
                                             allRingNodesUnlocked = false;
                                             break;
                                         }
                                     }
                                     if (allRingNodesUnlocked) {
                                         enableCenterNode();
                                     }
                                 });
                             });
                         } else {
                             animatePathSegment(currentNodeIndex - 1);
                         }
                    }
                } else if (currentNodeIndex === 6 && isCenterEnabled) {
                    // 已启用中心节点且密码正确
                    alert("中心节点解锁成功！即将进入下一阶段...");
                    // window.location.href = 'next.html';
                }

                 currentNodeIndex = null; // 操作成功后重置当前节点索引
            } else {
                // --- 密码错误 ---
                passwordInput.value = ''; // 清空输入框
                startCooldown(); // 启动冷却机制和倒计时显示
            }
        }

        // 动画函数：移动点沿着路径移动并显示路径
        function animatePathSegment(segmentIndex, onComplete = null) {
            const pathElement = segmentPaths[segmentIndex];
            if (!pathElement) return;

            const pathLength = pathElement.getTotalLength();
            pathElement.style.opacity = 1;
            pathElement.style.strokeDasharray = pathLength;
            pathElement.style.strokeDashoffset = pathLength;

            const startPoint = pathElement.getPointAtLength(0);
            travelingDot.setAttribute('cx', startPoint.x);
            travelingDot.setAttribute('cy', startPoint.y);
            travelingDot.style.display = 'block';

            let startTime = null;
            const duration = (segmentIndex === 4 || segmentIndex === 5) ? fullCircleAnimationDuration / 2 : animationDuration;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);

                const currentLength = pathLength * progress;
                const currentPoint = pathElement.getPointAtLength(currentLength);

                travelingDot.setAttribute('cx', currentPoint.x);
                travelingDot.setAttribute('cy', currentPoint.y);
                pathElement.style.strokeDashoffset = pathLength - currentLength;

                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    pathElement.style.strokeDashoffset = 0;
                    if (!onComplete) {
                       travelingDot.style.display = 'none';
                    }
                    if (onComplete) {
                        onComplete();
                    }
                }
            }
            requestAnimationFrame(step);
        }

        // 启用中心节点
        function enableCenterNode() {
            isCenterEnabled = true;
            centerNode.classList.add('enabled');
            console.log("中心节点已解锁！");
        }

        // --- 事件监听 ---
        nodes.forEach(node => {
            const index = parseInt(node.dataset.index);
            node.addEventListener('click', (e) => {
                 e.stopPropagation();

                 if (index === 6) { // 中心节点
                     currentNodeIndex = index;
                     showTooltip(isCenterEnabled);
                     return;
                 }

                 // 环形节点 (0-5)
                 // 节点0不需要前置解锁，节点1-5需要前一个解锁
                 if (index > 0 && !unlockedNodes[index - 1]) {
                     alert("请按顺序解锁前一个节点！");
                     return;
                 }

                 // 如果节点已解锁 (节点0默认已解锁)，只显示信息
                 if (unlockedNodes[index]) {
                     currentNodeIndex = index;
                     showTooltip(false); // 不显示密码表单
                 } else {
                      // 节点未解锁，且前一个已解锁 (或当前是节点0)，显示密码表单 (节点0不需要密码)
                      currentNodeIndex = index;
                      showTooltip(index >= 1 && index <= 5); // 节点1-5需要密码
                 }
            });
        });

        // 解锁按钮点击事件
        unlockButton.addEventListener('click', checkPassword);

        // 密码输入框回车事件
        passwordInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                checkPassword();
            }
        });

        // 点击提示框外部区域关闭
        document.addEventListener('click', (e) => {
             if (tooltip.style.display === 'block' &&
                 !e.target.closest('.tooltip') &&
                 !e.target.closest('.node'))
            {
                 // 只有当不在冷却中时才关闭提示框并清空状态
                 if (!isCoolingDown) {
                     tooltip.style.display = 'none';
                     currentNodeIndex = null;
                     errorMsg.textContent = '';
                     passwordInput.value = '';
                 }
                 // 如果在冷却中，点击外部不关闭，计时器会继续运行并更新 errorMsg
            }
        });

        // 页面加载后初始化
        positionNodes();
        createSegmentPaths();

    </script>
</body>
</html>