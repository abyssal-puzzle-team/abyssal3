<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ABYSSAL3 PUZZLE</title>
    <style>
        /* --- 基础和布局样式 --- */
        body {
            margin: 0;                      /* 移除默认边距 */
            padding: 0;                     /* 移除默认内边距 */
            background-color: #121212;      /* 深色背景 */
            color: #fff;                    /* 浅色文字 */
            font-family: Arial, sans-serif; /* 设置字体 */
            overflow: hidden;               /* 隐藏滚动条 */
            display: flex;                  /* 使用 Flexbox 布局 */
            justify-content: center;        /* 水平居中 */
            align-items: center;            /* 垂直居中 */
            min-height: 100vh;              /* 最小高度为视口高度 */
            /* 添加背景图片 */
            background-image: url('./img/background.jpeg');
            background-size: cover;         /* 图片覆盖整个背景区域 */
            background-repeat: no-repeat;   /* 图片不重复 */
            background-attachment: fixed;   /* 背景图片固定，不随滚动条滚动 */
            background-position: center;    /* 图片居中显示 */
        }

        /* --- 环形容器 --- */
        .ring-container {
            position: relative;             /* 作为内部绝对定位元素的参考 */
            width: 600px;                   /* 容器宽度 */
            height: 600px;                  /* 容器高度 */
        }

        /* --- 主圆环边框 --- */
        .main-ring {
            position: absolute;             /* 绝对定位 */
            width: 100%;                    /* 宽度占满容器 */
            height: 100%;                   /* 高度占满容器 */
            border: 4px solid rgba(204, 0, 0, .3); /* 红色半透明边框 */
            border-radius: 50%;             /* 圆形 */
            top: 0;                         /* 顶部对齐 */
            left: 0;                        /* 左侧对齐 */
            box-sizing: border-box;         /* 边框包含在宽高内 */
        }

        /* --- SVG 进度环 --- */
        .progress-svg {
            position: absolute;             /* 绝对定位 */
            width: 100%;                    /* 宽度占满容器 */
            height: 100%;                   /* 高度占满容器 */
            top: 0;                         /* 顶部对齐 */
            left: 0;                        /* 左侧对齐 */
            overflow: visible;              /* 允许内容（如发光效果或点）溢出 */
        }

        /* --- SVG 路径段 --- */
        .segment-path {
            fill: none;                     /* 无填充色 */
            stroke: #6cf;                   /* 路径颜色 (浅蓝色) */
            stroke-width: 5px;              /* 路径宽度 */
            stroke-linecap: round;          /* 路径端点为圆形 */
            opacity: 0;                     /* 初始透明 */
            transition: none;               /* 动画由 JS 控制，无需 CSS 过渡 */
        }

        /* --- SVG 移动的点 --- */
        .traveling-dot {
            fill: #fff;                     /* 点的颜色 (白色) */
            r: 5px;                         /* 点的半径 */
            display: none;                  /* 初始隐藏 */
        }

        /* --- 节点通用样式 --- */
        .node {
            position: absolute;             /* 绝对定位 */
            cursor: pointer;                /* 鼠标悬停时显示指针 */
            z-index: 2;                     /* 节点在 SVG 之上 */
            text-align: center;             /* 文本居中 (用于中心节点) */
            box-sizing: border-box;         /* 边框包含在宽高内 */
            border: 2px solid #fff;         /* 默认白色边框 */
            transition: background .3s ease, border-color .3s ease; /* 背景和边框颜色过渡 */
        }

        /* --- 节点形状和大小 (菱形、方形、中心) --- */
        .node.diamond, .node.square, .center-node {
            width: 40px;                    /* 常规节点宽度 */
            height: 40px;                   /* 常规节点高度 */
        }
        .node.diamond {
            background: #fff;               /* 菱形初始背景 (白色) */
            /* 旋转在 JS 中通过 transform 实现 */
        }
        .node.square {
            background: #333;               /* 方形初始背景 (深灰色) */
        }
        .center-node {
            width: 60px;                    /* 中心节点宽度 */
            height: 60px;                   /* 中心节点高度 */
            background: #333;               /* 中心节点初始背景 (深灰色) */
            opacity: .5;                    /* 中心节点初始半透明 */
            pointer-events: none;           /* 中心节点初始不可点击 */
            border-radius: 50%;             /* 中心节点为圆形 */
            display: flex;                  /* 使用 Flexbox 布局 */
            justify-content: center;        /* 内部文字水平居中 */
            align-items: center;            /* 内部文字垂直居中 */
            font-size: 14px;                /* 中心节点文字大小 */
            color: #fff;                    /* 中心节点文字颜色 */
            transition: opacity .3s ease, background .3s ease, color .3s ease, pointer-events .3s ease, border-color .3s ease; /* 多属性过渡 */
        }

        /* --- 解锁后的节点样式 --- */
        .node.unlocked.diamond, .node.unlocked.square {
            background: #6cf;               /* 解锁后背景色 (浅蓝色) */
            border-color: #6cf;             /* 解锁后边框色 (浅蓝色) */
        }
        .center-node.enabled {
            opacity: 1;                     /* 启用后不透明 */
            pointer-events: auto;           /* 启用后可点击 */
            background: #fff;               /* 启用后背景色 (白色) */
            color: #121212;                 /* 启用后文字颜色 (深色) */
            cursor: pointer;                /* 鼠标悬停时显示指针 */
            border-color: #fff;             /* 边框颜色 (白色) */
        }

        /* --- 提示框样式 --- */
        .tooltip {
            position: fixed;                /* 固定定位，不随页面滚动 */
            right: 20px;                    /* 距离右边 20px */
            top: 20px;                      /* 距离顶部 20px */
            width: 300px;                   /* 提示框宽度 */
            height: 80vh;                   /* 提示框高度 (视口高度的80%) */
            background: #1e1e1e;            /* 提示框背景色 (深灰色) */
            border: 2px solid #fff;         /* 提示框边框 (白色) */
            overflow-y: auto;               /* 内容超出时显示垂直滚动条 */
            padding: 10px;                  /* 内边距 */
            box-sizing: border-box;         /* 内边距和边框包含在宽高内 */
            display: none;                  /* 初始隐藏 */
            z-index: 3;                     /* 在其他元素之上 */
            color: #ccc;                    /* 提示框文字颜色 (浅灰色) */
        }
        #tooltipContent {
            margin-bottom: 20px;            /* 内容区域距离下方密码区域的间距 */
            word-wrap: break-word;          /* 允许长单词换行 */
            white-space: pre-wrap;          /* 保留空白符和换行符 */
        }
        .tooltip p {
            margin: 0 0 10px;               /* 段落间距 */
            line-height: 1.5;               /* 行高 */
        }

        /* --- 密码表单样式 --- */
        .password-form {
            position: sticky;               /* 相对于 tooltip 滚动区域固定在底部 */
            bottom: 0;                      /* 固定在底部 */
            background: #1e1e1e;            /* 背景色与 tooltip 一致 */
            padding: 10px 0 0;              /* 顶部内边距 */
            margin: 0;                      /* 无外边距 */
            width: 100%;                    /* 宽度占满 tooltip */
            box-sizing: border-box;         /* 内边距包含在宽度内 */
        }
        .password-form input[type=text] {
            width: calc(100% - 18px);       /* 宽度计算 (考虑内边距和边框) */
            padding: 8px;                   /* 输入框内边距 */
            margin-bottom: 5px;             /* 输入框下方间距 */
            box-sizing: border-box;         /* 内边距和边框包含在宽度内 */
            background: #333;               /* 输入框背景 (深灰色) */
            color: #fff;                    /* 输入框文字颜色 (白色) */
            border: 1px solid #666;         /* 输入框边框 (灰色) */
            display: block;                 /* 块级元素，占满一行 */
        }
        .password-form button {
            width: 100%;                    /* 按钮宽度占满 */
            padding: 8px;                   /* 按钮内边距 */
            background: #4caf50;            /* 按钮背景色 (绿色) */
            color: #fff;                    /* 按钮文字颜色 (白色) */
            border: none;                   /* 无边框 */
            cursor: pointer;                /* 鼠标指针 */
            display: block;                 /* 块级元素 */
            transition: background .3s ease;/* 背景色过渡 */
        }
        .password-form button:not(:disabled):hover {
            background: #45a049;            /* 鼠标悬停时的背景色 (深绿色) */
        }
        .password-form button:disabled {
            background: #666;               /* 禁用时背景色 (灰色) */
            cursor: not-allowed;            /* 禁用时鼠标样式 */
        }

        /* --- 错误消息样式 --- */
        .error {
            color: red;                     /* 错误消息颜色 (红色) */
            text-align: center;             /* 文本居中 */
            margin-top: 5px;                /* 顶部外边距 */
            font-size: .9em;                /* 字体稍小 */
            min-height: 1.2em;              /* 最小高度，防止布局跳动 */
        }

        /* --- 冷却激活时的视觉样式 --- */
        .password-form.cooldown-active input[type=text],
        .password-form.cooldown-active button {
            /* 使用 !important 确保覆盖默认样式 */
            background-color: #555 !important; /* 更深的灰色背景 */
            border-color: #777 !important;     /* 更深的灰色边框 */
            color: #aaa !important;            /* 灰白色文字 */
            cursor: not-allowed !important;    /* 禁用鼠标样式 */
            opacity: 0.7 !important;           /* 轻微透明 */
        }
        .password-form.cooldown-active button:hover {
             /* 覆盖悬停效果，保持禁用状态的颜色 */
            background-color: #555 !important;
        }
    </style>
</head>
<body>
    <!-- === 背景音乐标签 === -->
    <audio id="backgroundAudio" loop> <!-- 移除 autoplay，由 JS 控制 -->
        <source src="./mp3/main.mp3" type="audio/mpeg">
        您的浏览器不支持音频元素。
    </audio>
    <!-- === 音频结束 === -->

    <div class="ring-container">
        <!-- 主圆环 -->
        <div class="main-ring"></div>
        <!-- 进度环 SVG -->
        <svg class="progress-svg" viewBox="0 0 600 600">
            <!-- 定义 6 个路径段 -->
            <path id="segmentPath-0-1" class="segment-path"/> <path id="segmentPath-1-2" class="segment-path"/>
            <path id="segmentPath-2-3" class="segment-path"/> <path id="segmentPath-3-4" class="segment-path"/>
            <path id="segmentPath-4-5" class="segment-path"/> <path id="segmentPath-5-0" class="segment-path"/>
            <!-- 移动的点 -->
            <circle id="travelingDot" class="traveling-dot"/>
        </svg>
        <!-- 节点组 -->
        <div class="nodes">
            <!-- 定义 6 个环形节点和 1 个中心节点 -->
            <div class="node diamond" data-index="0"></div> <div class="node square" data-index="1"></div>
            <div class="node square" data-index="2"></div> <div class="node square" data-index="3"></div>
            <div class="node square" data-index="4"></div> <div class="node square" data-index="5"></div>
            <div class="node center-node" id="centerNode" data-index="6">中心</div>
        </div>
    </div>

    <!-- 提示框 -->
    <div class="tooltip" id="tooltip">
        <!-- 节点说明内容区域 -->
        <div id="tooltipContent">这里是节点说明文字...</div>
        <!-- 密码输入表单区域 -->
        <div class="password-form" id="passwordForm">
            <input type="text" id="passwordInput" placeholder="请输入密码">
            <button id="unlockButton">解锁</button>
            <div class="error" id="errorMsg"></div> <!-- 显示错误或冷却信息 -->
        </div>
    </div>

    <script>
        // ========== 可配置参数 ==========
        const API_BASE_URL = ''; // 后端 API 基础 URL
        const nodeAngles = [90, 150, 210, 270, 330, 30]; // 各节点在圆环上的角度
        const nodeDescriptions = [ // 各节点对应的说明文字
            "......", // 节点 0
            `【层面1:医院】
两人坠入闪烁红光的实验室。一阵疾促的电子音响起：「滴滴滴滴滴 滴哒哒滴 哒哒哒滴 滴滴滴滴滴」（Tip：滴持续时间似乎比哒长）。
地面翻转时，破损的全息屏显示：「记录条：患者编号____」。
【层面2:塔】
“快看，到了”“别嚷嚷”。像素塔之下传来声音“滴哒哒滴 滴哒哒哒 滴滴滴滴滴 滴哒哒哒哒滴 滴哒哒滴 滴滴滴哒哒 滴滴滴滴滴”（tip：“滴”的声音似乎比“哒”长）。奇怪的声音响完，世界突然倒了过来。两人摔了个踉跄。他们向前走了一步，抓住了谜题旁边柱子才勉强站稳。他们很快完成了谜题，并获得了一个评级。
【层面3:太空之诗】
宇宙飞船上，二人闲来无事，诗性大发，作诗一首：
最后一个信号在方程尽头结晶
猎枪卡进黎明的褶皱
信纸在星空背面生长褶皱
所有钟摆吞下箭的尾焰
恒星熄灭时灼烧网膜的酒精
时间在方程裂缝处开始脱水
左腿系着晨露编织的锚
右眼倒映着花序逆行的光斑
——这里每个意象都在回答同一道物理学谜题/概念
            `, // 节点 1
            "这是解锁序列的第二个正方形节点 (左上)。\n提示：后端密码是 NODE2_PASS", // 节点 2
            "这是解锁序列的第三个正方形节点 (顶部)。\n提示：后端密码是 NODE3_PASS", // 节点 3
            "这是解锁序列的第四个正方形节点 (右上)。\n提示：后端密码是 NODE4_PASS", // 节点 4
            "这是解锁序列的第五个正方形节点 (右下)。\n解锁它将开启中心节点。\n提示：后端密码是 NODE5_PASS", // 节点 5
            "恭喜！你已解锁所有环形节点，中心节点已启用。\n点击此中心节点即可进入下一阶段。" // 节点 6 (中心)
        ];
        const animationDuration = 1000; // 单个路径段动画时长 (毫秒)
        const fullCircleSegmentDuration = 1000; // 闭合圆环动画时长 (毫秒)
        const NEXT_PAGE_URL = 'next.html'; // 点击中心节点后跳转的页面
        // ========== 配置结束 ==========

        // --- 获取 DOM 元素 ---
        const nodes = document.querySelectorAll('.node');
        const tooltip = document.getElementById('tooltip');
        const tooltipContent = document.getElementById('tooltipContent');
        const passwordForm = document.getElementById('passwordForm');
        const passwordInput = document.getElementById('passwordInput');
        const unlockButton = document.getElementById('unlockButton');
        const errorMsg = document.getElementById('errorMsg');
        const centerNode = document.getElementById('centerNode');
        const travelingDot = document.getElementById('travelingDot');
        const audioElement = document.getElementById('backgroundAudio');
        const segmentPaths = [];
        for (let i = 0; i < 6; i++) {
            segmentPaths.push(document.getElementById(`segmentPath-${i}-${(i + 1) % 6}`));
        }

        // --- 状态变量 ---
        let unlockedNodes = [true, false, false, false, false, false]; // 节点解锁状态
        let isCenterEnabled = false; // 中心节点是否启用
        let currentNodeIndex = null; // 当前交互的节点索引
        const radius = 298; // 圆环半径
        const containerSize = 600; // 容器大小
        const circleCenterX = containerSize / 2; // 圆心 X
        const circleCenterY = containerSize / 2; // 圆心 Y
        let activeCooldownTimer = null; // 冷却倒计时 interval ID
        let activeCooldownTimeout = null; // 冷却结束 timeout ID

        // --- 初始化设置 ---
        positionNodes();
        createSegmentPaths();
        const startNodeElement = document.querySelector('.node[data-index="0"]');
        if (startNodeElement) startNodeElement.classList.add('unlocked');

        // --- 函数定义 ---

        /** 计算节点 SVG 坐标 */
        function calculateNodeSvgPosition(angleDeg) {
            const angleRad = angleDeg * Math.PI / 180;
            return {
                x: circleCenterX + radius * Math.cos(angleRad),
                y: circleCenterY + radius * Math.sin(angleRad)
            };
        }

        /** 定位所有节点 */
        function positionNodes() {
            nodes.forEach((node) => {
                const index = parseInt(node.dataset.index);
                if (index === 6) { // 中心节点
                    node.style.left = '50%';
                    node.style.top = '50%';
                    node.style.transform = 'translate(-50%, -50%)';
                } else { // 环形节点
                    const angleDeg = nodeAngles[index];
                    const svgPos = calculateNodeSvgPosition(angleDeg);
                    node.style.top = `${svgPos.y}px`;
                    node.style.left = `${svgPos.x}px`;
                    let transform = 'translate(-50%, -50%)';
                    if (node.classList.contains('diamond')) transform += ' rotate(45deg)';
                    node.style.transform = transform;
                }
            });
        }

        /** 创建 SVG 路径 */
        function createSegmentPaths() {
            for (let i = 0; i < 6; i++) {
                const startPos = calculateNodeSvgPosition(nodeAngles[i]);
                const endPos = calculateNodeSvgPosition(nodeAngles[(i + 1) % 6]);
                const pathData = `M ${startPos.x} ${startPos.y} A ${radius} ${radius} 0 0 1 ${endPos.x} ${endPos.y}`;
                const pathElement = segmentPaths[i];
                if (pathElement) {
                    pathElement.setAttribute('d', pathData);
                    const pathLength = pathElement.getTotalLength();
                    pathElement.style.strokeDasharray = pathLength;
                    pathElement.style.strokeDashoffset = pathLength;
                    pathElement.style.opacity = 0;
                }
            }
        }

        /** 清理冷却状态 */
        function clearCooldownState(forceClearMessage = false) {
            if (activeCooldownTimer) clearInterval(activeCooldownTimer);
            if (activeCooldownTimeout) clearTimeout(activeCooldownTimeout);
            activeCooldownTimer = null;
            activeCooldownTimeout = null;
            passwordForm.classList.remove('cooldown-active');
            passwordInput.disabled = false;
            unlockButton.disabled = false;
            unlockButton.textContent = '解锁';
            if (forceClearMessage) errorMsg.textContent = '';
        }

        /** 显示提示框 */
        function showTooltip(nodeIndexToShow, needsPassword, cooldownMessage = null, remainingSeconds = 0) {
            if (nodeIndexToShow === null) return;
            tooltip.style.display = 'block';
            tooltipContent.textContent = nodeDescriptions[nodeIndexToShow];
            passwordInput.value = '';
            clearCooldownState(true); // 总是先清理

            if (cooldownMessage) { // 情况1: 传入了冷却信息
                passwordForm.style.display = 'block';
                passwordForm.classList.add('cooldown-active');
                passwordInput.disabled = true;
                unlockButton.disabled = true;
                unlockButton.textContent = '请等待...';
                errorMsg.textContent = cooldownMessage; // 显示传入的冷却消息
                startFrontendCooldownTimers(remainingSeconds, nodeIndexToShow); // 启动前端计时器
            } else if (needsPassword) { // 情况2: 需要密码输入
                passwordForm.style.display = 'block';
            } else { // 情况3: 只显示信息
                passwordForm.style.display = 'none';
            }
            tooltip.scrollTop = 0;
        }

        /** 启动前端冷却计时器 */
        function startFrontendCooldownTimers(remaining, indexToCheck) {
             passwordInput.disabled = true;
             unlockButton.disabled = true;
             passwordForm.classList.add('cooldown-active');
             unlockButton.textContent = '请等待...';

             let countdown = Math.ceil(remaining); // 向上取整，确保显示完整秒数

             // 清除旧计时器
             if (activeCooldownTimer) clearInterval(activeCooldownTimer);
             if (activeCooldownTimeout) clearTimeout(activeCooldownTimeout);

             // --- 更新显示 ---
             const updateTimerDisplay = () => {
                  if (tooltip.style.display === 'block' && passwordForm.style.display === 'block' && currentNodeIndex === indexToCheck) {
                     if (countdown > 0) {
                         errorMsg.textContent = `请求过于频繁，请等待 ${countdown} 秒...`;
                         countdown--;
                     } else {
                         errorMsg.textContent = `请稍候...`; // 倒计时结束的临时消息
                         if(activeCooldownTimer) clearInterval(activeCooldownTimer);
                         activeCooldownTimer = null;
                     }
                 } else { // tooltip 状态改变，停止计时器
                     if(activeCooldownTimer) clearInterval(activeCooldownTimer);
                     activeCooldownTimer = null;
                 }
             };

             updateTimerDisplay(); // 立即显示一次
             activeCooldownTimer = setInterval(updateTimerDisplay, 1000); // 每秒更新

             // --- 冷却结束后恢复 ---
             activeCooldownTimeout = setTimeout(() => {
                 activeCooldownTimer = null; // 清理 interval ID
                  if (tooltip.style.display === 'block' && passwordForm.style.display === 'block' && currentNodeIndex === indexToCheck) {
                     console.log(`节点 ${indexToCheck} 前端冷却结束。`);
                     clearCooldownState(false); // 清理状态，不强制清除消息
                     errorMsg.textContent = ''; // 明确清除冷却消息
                 } else {
                      console.log(`服务器冷却结束但 tooltip 状态改变。`);
                      clearCooldownState(true); // 清理状态和消息
                 }
                 activeCooldownTimeout = null; // 清理 timeout ID
             }, remaining * 1000); // 使用原始的 remaining 时间来设置 timeout
        }

        /** 异步检查密码 */
        async function checkPassword() {
            if (currentNodeIndex === null || currentNodeIndex < 1 || currentNodeIndex > 5) return;
            const input = passwordInput.value;
            const indexToCheck = currentNodeIndex;

            unlockButton.disabled = true;
            passwordInput.disabled = true;
            unlockButton.textContent = '验证中...';
            errorMsg.textContent = '';
            passwordForm.classList.remove('cooldown-active');
            clearCooldownState(false); // 清理计时器但不清消息

            try {
                const response = await fetch('https://abyssal3.asterveil.top/api/check-password', { // 使用指定 API
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nodeIndex: indexToCheck, password: input }),
                 });
                let data = {};
                try { data = await response.json(); } catch (e) { data = { message: `服务器响应无效 (状态: ${response.status})` }; }

                if (response.ok && data.correct) { // 密码正确
                    console.log(`节点 ${indexToCheck} 密码正确。`);
                    tooltip.style.display = 'none';
                    clearCooldownState(true);
                     if (!unlockedNodes[indexToCheck]) {
                         unlockedNodes[indexToCheck] = true;
                         const targetNode = document.querySelector(`.node[data-index="${indexToCheck}"]`);
                         const segmentIndex = indexToCheck - 1;
                         if (indexToCheck === 5) { // 解锁最后一个节点
                             animatePathSegment(segmentIndex, fullCircleSegmentDuration, () => {
                                 if (targetNode) targetNode.classList.add('unlocked');
                                 animatePathSegment(5, fullCircleSegmentDuration, () => {
                                     segmentPaths.forEach(p => { p.style.opacity = 1; p.style.stroke = '#6cf'; p.style.strokeDashoffset = 0; });
                                     if (unlockedNodes.slice(1).every(Boolean)) enableCenterNode();
                                 });
                             });
                         } else { // 解锁中间节点
                             animatePathSegment(segmentIndex, animationDuration, () => {
                                 if (targetNode) targetNode.classList.add('unlocked');
                             });
                         }
                    }
                    currentNodeIndex = null;
                } else { // 密码错误或冷却
                    passwordInput.value = '';
                    if (data.cooldown && data.remaining > 0) { // 后端指示冷却
                        errorMsg.textContent = data.message || `密码错误！请等待 ${Math.ceil(data.remaining)} 秒...`;
                        startFrontendCooldownTimers(data.remaining, indexToCheck);
                    } else { // 普通错误
                        errorMsg.textContent = data.message || '密码错误！';
                        clearCooldownState(false); // 重新启用输入
                    }
                }
            } catch (error) { // fetch 错误
                console.error('检查密码时出错:', error);
                errorMsg.textContent = '验证时发生网络错误，请稍后重试。';
                clearCooldownState(false); // 重新启用输入
            }
        }

        /** 动画 SVG 路径 */
        function animatePathSegment(segmentIndex, duration, onComplete = null) {
            const pathElement = segmentPaths[segmentIndex];
            if (!pathElement) { if (onComplete) onComplete(); return; }
            const pathLength = pathElement.getTotalLength();
            pathElement.style.opacity = 1;
            pathElement.style.strokeDasharray = pathLength;
            pathElement.style.strokeDashoffset = pathLength;
            const startPoint = pathElement.getPointAtLength(0);
            travelingDot.setAttribute('cx', startPoint.x);
            travelingDot.setAttribute('cy', startPoint.y);
            travelingDot.style.display = 'block';
            let startTime = null;
            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const currentLength = pathLength * progress;
                const currentPoint = pathElement.getPointAtLength(currentLength);
                travelingDot.setAttribute('cx', currentPoint.x);
                travelingDot.setAttribute('cy', currentPoint.y);
                pathElement.style.strokeDashoffset = pathLength - currentLength;
                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    pathElement.style.strokeDashoffset = 0;
                    travelingDot.style.display = 'none';
                    if (onComplete) onComplete();
                }
            }
            requestAnimationFrame(step);
        }

        /** 启用中心节点 */
        function enableCenterNode() {
            if (!isCenterEnabled) {
                isCenterEnabled = true;
                centerNode.classList.add('enabled');
                console.log("meta已开启");
            }
        }

        // --- 音频播放逻辑 ---
        let audioPlayed = false;
        function tryPlayAudio() {
            if (!audioElement || audioPlayed) return;
            const playPromise = audioElement.play();
            if (playPromise !== undefined) {
                playPromise.then(() => {
                    console.log("背景音频已开始播放。");
                    audioPlayed = true;
                    document.removeEventListener('click', tryPlayAudio);
                    document.removeEventListener('keydown', tryPlayAudio);
                }).catch(error => {
                    console.warn("音频自动播放失败 (需要用户交互):", error.name, error.message);
                });
            }
        }

        // --- 事件监听器 ---
        document.addEventListener('click', tryPlayAudio, { once: false });
        document.addEventListener('keydown', tryPlayAudio, { once: false });

        // --- 节点点击事件 ---
        nodes.forEach(node => {
            const index = parseInt(node.dataset.index);
            node.addEventListener('click', async (e) => { // 改为 async
                 e.stopPropagation();

                 if (index === 6) { // 中心节点
                     if (isCenterEnabled) window.location.href = NEXT_PAGE_URL;
                     else { currentNodeIndex = index; showTooltip(index, false); }
                     return;
                 }

                 // --- 环形节点 (0-5) ---
                 if (tooltip.style.display === 'block' && passwordInput.disabled && currentNodeIndex !== index) {
                     console.log("在冷却或验证期间阻止了节点切换。");
                     return;
                 }
                 if (tooltip.style.display === 'block' && currentNodeIndex !== null && currentNodeIndex !== index) {
                     tooltip.style.display = 'none';
                     clearCooldownState(true);
                 }

                 currentNodeIndex = index;

                 if (index > 0 && !unlockedNodes[index - 1]) { // 检查前置解锁
                     alert("请按顺序解锁前一个节点！");
                     currentNodeIndex = null; tooltip.style.display = 'none'; clearCooldownState(true); return;
                 }

                 const needsPasswordCheck = index >= 1 && index <= 5 && !unlockedNodes[index];

                 if (needsPasswordCheck) {
                     // === 需要密码：先检查后端冷却状态 ===
                     console.log(`节点 ${index} 被点击，正在检查后端冷却状态...`);
                     node.style.cursor = 'wait'; // 等待光标
                     errorMsg.textContent = '正在检查状态...'; // 提示用户
                     tooltip.style.display = 'block'; // 先显示tooltip骨架
                     passwordForm.style.display = 'none'; // 隐藏密码区
                     tooltipContent.textContent = nodeDescriptions[index]; // 显示描述

                     try {
                         const response = await fetch('https://abyssal3.asterveil.top/api/check-cooldown'); // 使用指定 API (假设是 GET)
                         if (!response.ok) throw new Error(`冷却状态检查失败: ${response.status}`);

                         const cooldownStatus = await response.json();
                         errorMsg.textContent = ''; // 清除"正在检查"消息

                         if (cooldownStatus.cooldown && cooldownStatus.remaining > 0) {
                             // --- 后端报告冷却中 ---
                             console.log(`节点 ${index}: 后端报告冷却中 (${cooldownStatus.remaining}s 剩余). 显示冷却信息。`);
                             showTooltip(index, false, `请求过于频繁，请等待 ${Math.ceil(cooldownStatus.remaining)} 秒...`, cooldownStatus.remaining);
                         } else {
                             // --- 不在冷却中 ---
                              console.log(`节点 ${index}: 不在冷却中。显示密码输入提示。`);
                             showTooltip(index, true); // 显示带密码框的 Tooltip
                         }
                     } catch (error) {
                         // --- 预检请求失败 ---
                         console.error("检查冷却状态时出错:", error);
                         errorMsg.textContent = '无法检查节点状态，请稍后重试或直接尝试。'; // 保持错误信息
                         // 允许用户尝试输入密码作为后备
                         passwordForm.style.display = 'block';
                         passwordInput.disabled = false;
                         unlockButton.disabled = false;
                         unlockButton.textContent = '解锁';
                         passwordForm.classList.remove('cooldown-active');
                     } finally {
                         node.style.cursor = 'pointer'; // 恢复光标
                     }
                 } else {
                      // --- 不需要密码 ---
                      console.log(`节点 ${index} 被点击，仅显示信息。`);
                      showTooltip(index, false); // 只显示信息
                 }
            });
        });

        // --- 解锁按钮点击 ---
        unlockButton.addEventListener('click', checkPassword);

        // --- 密码框回车 ---
        passwordInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter' && !passwordInput.disabled) {
                event.preventDefault(); checkPassword();
            }
        });

        // --- 点击外部关闭 tooltip ---
        document.addEventListener('click', (e) => {
             if (tooltip.style.display === 'block' && !e.target.closest('.tooltip') && !e.target.closest('.node')) {
                 if (!passwordInput.disabled) { // 仅在非冷却/验证时允许关闭
                     tooltip.style.display = 'none'; currentNodeIndex = null; clearCooldownState(true);
                 } else { console.log("在冷却/验证期间阻止了点击外部关闭 tooltip。"); }
            }
        });

    </script>
</body>
</html>